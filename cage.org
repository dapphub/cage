#+TITLE: Global Settlement
#+DATE: <2019-01-24 Thu>
#+AUTHOR:
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+OPTIONS: html-postamble:nil tex:mathjax
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+PROPERTY: header-args :results output :exports both :noweb strip-export :tangle no
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./body.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./theme.css"/>
#+HTML_HEAD_EXTRA: <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="/home/lev/src/MathJax/MathJax.js?config=TeX-AMS_HTML-full"><\/script>')</script>

#+OPTIONS:
# Local Variables:
# org-confirm-babel-evaluate: nil
# org-babel-exp-code-template: "#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC"
# End:

#+NAME: solidity-skeleton
#+BEGIN_SRC sol :tangle "src/cage.sol" :exports none
  /// cage.sol -- global settlement engine

  // <<license>>

  pragma solidity >=0.5.0;

  contract VatLike {
      function dai(bytes32 lad) public returns (uint256);
      function ilks(bytes32 ilk) public returns (uint256, uint256, uint256, uint256);
      function urns(bytes32 ilk, bytes32 urn) public returns (uint256, uint256);
      function move(bytes32 src, bytes32 dst, int256 rad) public;
      function flux(bytes32 ilk, bytes32 src, bytes32 dst, int256 rad) public;
      function tune(bytes32 i, bytes32 u, bytes32 v, bytes32 w, int256 dink, int256 dart) public;
      function grab(bytes32 i, bytes32 u, bytes32 v, bytes32 w, int256 dink, int256 dart) public;
      function heal(bytes32 u, bytes32 v, int256 rad) public;
      function cage() public;
  }
  contract PitLike {
      function cage() public;
  }
  contract CatLike {
      function cage() public;
  }
  contract VowLike {
      function Joy() public returns (uint256);
      function Woe() public returns (uint256);
      function hump() public returns (uint256);
      function heal(uint256 wad) public;
  }

  contract End {

      // --- Auth ---
      <<auth>>

      // --- Data ---
      <<data>>

      // --- Init ---
      <<init>>

      // --- Helpers ---
      <<helper>>

      // --- Math ---
      <<math>>

      // --- Administration ---
      <<file>>

      // --- Settlement ---
      <<cage>>

      <<cage-ilk>>

      <<skim>>

      <<shut>>

      <<shop>>

      <<pack>>

      <<cash>>

      <<vent>>
  }
#+END_SRC

#+NAME: act-skeleton
#+BEGIN_SRC act :tangle "act/cage.act" :exports none
   // <<license>>

   <<act-file>>

   <<act-cage>>

   <<act-cage-ilk>>

   <<act-skim>>

   <<act-shut>>

   <<act-shop>>

   <<act-pack>>

   <<act-cash>>

   <<act-vent>>
#+END_SRC

* License
#+NAME: license
#+BEGIN_SRC fundamental
  Copyright (C) 2018 Rain <rainbreak@riseup.net>
  Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC


* Setup
We will require safe addition and multiplication, as well as =ray= fixed-point multiplication:
#+NAME: math
#+BEGIN_SRC sol
  function add(uint x, uint y) internal pure returns (uint z) {
      z = x + y;
      require(z >= x);
  }
  function mul(uint x, uint y) internal pure returns (uint z) {
        z = x * y;
        require(y == 0 || z / y == x);
    }
  uint constant ONE = 10 ** 27;
  function rmul(uint x, uint y) internal pure returns (uint z) {
      z = x * y;
      require(y == 0 || z / y == x);
      z = z / ONE;
  }
  function u2i(uint x) internal pure returns (int y) {
      y = int(x);
      require(y >= 0);
  }

  function min(uint x, uint y) internal pure returns (uint z) {
      if (x <= y) { z = x; } else { z = y; }
  }
#+END_SRC

We define a function for casting an =address= to a =bytes32=:
#+NAME: helper
#+BEGIN_SRC sol
  function b32(address a) internal pure returns (bytes32 b) {
      b = bytes32(bytes20(a));
  }
#+END_SRC

The storage layout of the =End= is as follows:
#+NAME: data
#+BEGIN_SRC sol
  VatLike  public vat;
  PitLike  public pit;
  CatLike  public cat;
  VowLike  public vow;
  uint256  public live;

  mapping (address => uint256)                      public dai;
  mapping (bytes32 => uint256)                      public tags;
  mapping (bytes32 => uint256)                      public fixs;
  mapping (bytes32 => mapping (bytes32 => uint256)) public bags;
#+END_SRC

=End= uses the same multiowner auth model as the other =dss= contracts:

#+NAME: auth
#+BEGIN_SRC sol
  mapping (address => uint) public wards;
  function rely(address guy) public auth { wards[guy] = 1; }
  function deny(address guy) public auth { wards[guy] = 0; }
  modifier auth { require(wards[msg.sender] == 1); _; }
#+END_SRC

The constructor simply sets the creating account as owner and marks the system as =live=, i.e. uncaged:
#+NAME: init
#+BEGIN_SRC sol
  constructor() public {
      wards[msg.sender] = 1;
      live = 1;
  }
#+END_SRC

The target contracts of the =End= can be modified by owners in-flight:

#+NAME: file
#+BEGIN_SRC sol
  function file(bytes32 what, address data) public auth {
      if (what == "vat")  vat  = VatLike(data);
      if (what == "pit")  pit  = PitLike(data);
      if (what == "cat")  cat  = CatLike(data);
      if (what == "vow")  vow  = VowLike(data);
  }
#+END_SRC

#+NAME: act-file
#+BEGIN_SRC act
  behaviour file of End
  interface file(bytes32 what, address data)

  types

      Vat_was  : address
      Pit_was  : address
      Cat_was  : address
      Vow_was  : address

  storage

      wards[CALLER_ID] |-> Can
      Vat  |-> Vat_was => #if what == #string2Word("vat")  #then data else Vat_was
      Pit  |-> Pit_was => #if what == #string2Word("pit")  #then data else Pit_was
      Cat  |-> Cat_was => #if what == #string2Word("cat")  #then data else Cat_was
      Vow  |-> Vow_was => #if what == #string2Word("vow")  #then data else Vow_was

  iff

      Can == 1
#+END_SRC

* The global settlement process
First, the top-level =cage= method is called, which sets the =live= flag to zero and initiates =cage= in the other relevant system modules:

#+NAME: cage
#+BEGIN_SRC sol
  function cage(uint256 dump) public auth {
      // require(live == 1); ???
      vat.cage();
      pit.cage();
      cat.cage();
      vow.heal(min(vow.Joy(), vow.Woe()));
      vat.move(b32(address(vow)), b32(address(this)), u2i(min(mul(vow.Joy(), ONE), mul(vow.hump(), dump))));
      live = 0;
  }
#+END_SRC

#+NAME: act-cage
#+BEGIN_SRC act
  behaviour cage of End
  interface cage(uint256 dump)

  types

      Can      : uint256
      Vat      : address
      Pit      : address
      Cat      : address
      Vow      : address
      Can_vat  : uint256
      Can_pit  : uint256
      Can_cat  : uint256
      Can_vow  : uint256
      Live     : uint256
      Vat_live : uint256
      Pit_live : uint256
      Cat_live : uint256
      Vow_live : uint256

  storage

      wards[CALLER_ID] |-> Can
      pit  |-> Pit
      cat  |-> Cat
      vow  |-> Vow
      live |-> Live => 0

  storage Pit

      wards[ACCT_ID] |-> Can_pit
      live           |-> Pit_live => 0

  storage Cat

      wards[ACCT_ID] |-> Can_cat
      live |-> Cat_live => 0

  storage Vow

      wards[ACCT_ID] |-> Can_vow
      live |-> Vow_live => 0
      // TODO: burn hump * dump

  storage Vat

      wards[ACCT_ID] |-> Can_vat
      live |-> Vat_live => 0

  iff

      //??Live == 1
      Can      == 1
      Can_vat == 1
      Can_pit  == 1
      Can_cat  == 1
      Can_vow  == 1
#+END_SRC

The /=hump= burn ratio/, here called =dump=, is a parameter that determines what fraction of the =Vow='s dai buffer is to be burned: =0= if none of it, and =wad= if all of it.

Next, the per-=Ilk= =cage= method is called, supplying a quantity called the =fix=, once for each collateral type. We will also write \( {\tt pump} := \frac{{\tt debt} - {\tt vice}}{{\tt debt} - {\tt vice} - {\tt hump}\cdot{\tt dump}} \) for the /=hump= burn multiplier/.

#+NAME: cage-ilk
#+BEGIN_SRC sol
  function cage(bytes32 ilk, uint256 tag, uint256 fix) public auth {
      require(live == 0);
      tags[ilk] = tag;
      fixs[ilk] = fix;
  }
#+END_SRC

#+NAME: act-cage-ilk
#+BEGIN_SRC act
  behaviour cage-ilk of End
  interface cage(bytes32 ilk, uint256 tag, uint256 fix)

  types

      Can  : uint256
      Live : uint256

  storage

      wards[CALLER_ID] |-> Can
      live             |-> Live
      tags[ilk]        |-> _ => tag
      fixs[ilk]        |-> _ => fix

  iff

      Can  == 1
      Live == 0
#+END_SRC

** Interlude: the =fix= computation

The =fix= represents the quantity of =gem= that a user will be able to redeem for one dai. We now describe the procedure by which it should be computed, presumably by an off-chain agent. In the following calculation, for notational simplicity, the appropriate operations for fixed point units are implicit, e.g. \( {\tt hump} \cdot {\tt dump} \) is the number of dai from the =hump= that will be burned, \( {\tt art_{iu}} \cdot {\tt rate_i} \) is the outstanding dai debt of CDP =u=, etc.

*** TODO If the ongoing collateral auctions finish in deficit

*** If the ongoing collateral auctions finish in adequacy

We assume that all of the collateral pending liquidation in the =Vow= will raise enough dai to cover the outstanding =vice=. In the current design, this is impossible to predict in advance, since the auctions will continue running well past the time that global settlement is initiated. Thus, this is a risk that we have to tolerate.

In this case, the total quantity of dai that must be redeemable through =End= is the total dai supply, minus the amount of dai that will be consumed through =flip= and =flop= auctions, minus the amount from the =hump= that was burned during =Vow.cage(dump)=, i.e.:

\[
{\tt debt} - {\tt vice} - {\tt hump \cdot dump}
\]

The first priority is to ensure that there is no race condition. That is to say, that with the \( {\tt fix_i}\) and \({\tt tag_i} \) that we chosen, every dai holder will be able to redeem the same quantity of =gem=, regardless of when they interact with the =End=, i.e.:

\[
\sum_u {\tt war_{iu}} = {\tt fix_i} \cdot ({\tt debt} - {\tt vice} - {\tt hump \cdot dump })
\]

We shall call this the /no-race property/. Setting \( {\tt war_{iu}} \) to be \( \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i }) \), where \( {\tt tag_i} \) is some /CDP settlement rate/, to be determined, we can solve for \( {\tt fix_i } \):

\[
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }}
\]

Another desirable feature is for all =gem= redeemable for one dai to be worth one dollar:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1
\]

We call this the /dai parity property/. Similarly, it is desirable for CDPs to be settled at the market value of their collateral, i.e. that:

\[
{\tt tag_i } = \frac{1}{p_i}
\]

We call this the /CDP parity property/.

**** In the absence of undercollateralised positions

Consider the case where no CDPs are undercollateralised, i.e. that for all =u=, \( {\tt art_{iu}} \cdot {\tt rate_i} \geq {\tt ink_{iu}} \cdot p_{{\tt i}} \). Then we can satisfy all three constraints simultaneously simply by setting \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \):

\[
{\tt fix_i} = \frac{{\tt rate_i} \cdot {\tt tag_i } \cdot {\tt Art_i}}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }} = \frac{{\tt rate_i} \cdot {\tt Art_i}}{p_{{\tt i}}\cdot({\tt debt} - {\tt vice} - {\tt hump \cdot dump })}
\]

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = \frac{\sum_i {\tt rate_i} \cdot {\tt Art_i}}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }} = \frac{{\tt debt} - {\tt vice}}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }} = {\tt pump}
\]

from which it is clear that we could use \( {\tt dump } = 0 \) and satisfy the no-race property and both parity properties.

**** In the presence of undercollateralised positions

***** Ensuring CDP parity:

Now if some CDPs had been undercollateralised, we would have had instead:

\begin{equation}
\label{eq:fixcdpparity}
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, \frac{{\tt art_{iu}} \cdot {\tt rate_i}}{p_{{\tt i}}})}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }} = \frac{{\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i}}{p_{{\tt i}}({\tt debt} - {\tt vice} - {\tt hump \cdot dump })}
\end{equation}

and the value redeemable from one dai would be:

\begin{align*}
\sum_i {\tt fix_i} \cdot p_{{\tt i}} & = \frac{\sum_i {\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i} }{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }} \\
                                     & = \frac{{\tt debt} - {\tt Gap}}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }}
\end{align*}

where \( {\tt gap_i} := \sum_u \mathrm{max} (0, {\tt art_{iu}} \cdot {\tt rate_i} - p_{{\tt i}} \cdot {\tt ink_i}) \) and \( {\tt Gap} := \sum_i {\tt gap_i} \), are the per =Ilk= and global gross negative CDP equity, respectively. Thus, though we have ensured the no-race and CDP parity properties, we have not necessarily ensured dai parity. However, if =hump= is large enough relative to =Gap=, it may be possible to ensure that the above expression equals one, solely by increasing =dump=.

***** Ensuring dai parity:

We might also be able to set \( {\tt tag_i } \) and \( {\tt fix_i } \) so as to guarantee dai parity. We could start by postulating that for all \( {\tt i} \):

\begin{equation}
\label{eq:fixdaiparity}
{\tt fix_i} \cdot p_{{\tt i}} = \frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt} - {\tt vice}}
\end{equation}

which will ensure that \( \sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1 \) due to the fundamental equation of dai.

It remains to choose the \( {\tt tag_i} \) such that losses from undercollateralised CDPs of =Ilk= =i= are socialised across all CDPs of the =Ilk=. This means that we will only be able to guarantee parity in the case that each =Ilk= is on aggregate not undercollateralised. We also have a choice about how exactly to socialise losses across CDPs: proportionally to their debt or to their collateral.

****** TODO socialising proportionally to collateral

If socialising proportionally to collateral, we have:
\begin{equation}
\label{eq:tagdaiparity-collateral}
{\tt tag_i } = ???
\end{equation}

****** socialising proportionally to debt

If socialising proportionally to debt, we have to solve the following for \( {\tt tag_i} \):

\begin{equation}
\label{eq:tagdaiparity-debt}
\frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt} - {\tt vice}} = p_{{\tt i}} \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt} - {\tt vice} - {\tt hump \cdot dump }}
\end{equation}

This is a linear optimisation problem without a closed-form solution, which can be solved numerically by linear complementarity methods. It is easy to see that a solution exists precisely when

\[
{\tt Art_i} \cdot {\tt rate_i} \leq {\tt Ink_i} \cdot p_{\tt i} \cdot {\tt pump}
\]

i.e. the =Ilk= as a whole is not undercollateralised (after adjusting for the =dump=). Note also that when there are no undercollateralised CDPs in the =Ilk= =i= and with \( {\tt dump = 0} \), equation \ref{eq:tagdaiparity-debt} can be solved with \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \), so this generalises our previous solution. Note that there is again a choice of how much of the =hump= to burn, where if more of the =hump= is burned then a smaller loss is imposed on CDP holders.

**** Summary of parity conditions
To summarise, when there are undercollateralised CDPs, the options are:
***** Ensure CDP parity:
set \( {\tt tag_i} = \frac{1}{p_i} \) and \( {\tt fix_i} \) according to formula \ref{eq:fixcdpparity}. It may still be possible to also ensure dai parity with =dump= if the =hump= is large enough.
***** Ensure DAI parity:
in both cases, set =dump = 1= and \( {\tt fix_i} \) according to formula \ref{eq:fixdaiparity}.
****** TODO by socialising proportionally to collateral
Set \( {\tt tag_i} \) according to formula \ref{eq:tagdaiparity-collateral}.
****** by socialising proportionally to debt
Set \( {\tt tag_i} \) according to formula \ref{eq:tagdaiparity-debt}.

**** TODO In the presence of an undercollateralised =Ilk=

A different calculation is necessary if there is an =Ilk= which is undercollateralised in aggregate, i.e. has \( {\tt Art_i} \cdot {\tt rate_i} \lt {\tt gap_i} \), and parity is desired. In that case, it is necessary to set the \( {\tt fix_i} \) in such a way as to socialise the losses from the undercollateralised =Ilk= across other collateral types. This calculation is TBA.

** CDP Settlement
Once =tag_i= has been provided, individual CDPs can be processed with =skim=, settling the position at the price implied by =tag_i=. This method is public, and both CDP holders and dai holders are incentivised to call it: the former in order to withdraw their remaining collateral, and the latter in order to make collateral available for redemption.
#+NAME: skim
#+BEGIN_SRC sol
  function skim(bytes32 ilk, bytes32 urn) public {
      require(tags[ilk] != 0);

      (uint take, uint rate, uint Ink, uint Art) = vat.ilks(ilk); Art; Ink; take;
      (uint ink, uint art) = vat.urns(ilk, urn);

      // assumes take is ONE
      uint war = min(ink, rmul(rmul(art, rate), tags[ilk]));

      vat.grab(ilk, urn, b32(address(this)), b32(address(this)), -int(war), -int(art));
  }
#+END_SRC

#+NAME: act-skim
#+BEGIN_SRC act
  behaviour skim of End
  interface skim(bytes32 ilk, bytes32 urn)

  types

      Tag    : uint256
      Vat    : address
      Can    : uint256
      Rate   : uint256
      Ink_u  : uint256
      Art_u  : uint256
      Ink    : uint256
      Art    : uint256
      Gem    : uint256
      Sin    : uint256
      Vice   : uint256

  storage

      tags[ilk] |-> Tag
      vat       |-> Vat

  storage Vat

      wards[ACCT_ID]     |-> Can
      ilks[ilk].rate     |-> Rate
      urns[ilk][urn].ink |-> Ink_u => Ink_u - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      urns[ilk][urn].art |-> Art_u => 0
      ilks[ilk].Ink      |-> Ink   => Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      ilks[ilk].Art      |-> Art   => Art - Art_u
      gem[ilk][ACCT_ID]  |-> Gem   => Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      sin[ACCT_ID]       |-> Sin   => Sin - Rate * Art_u
      vice               |-> Vice  => Vice - Rate * Art_u

  iff in range uint256

      Ink_u * #rmul(#rmul(Art_u, Rate), Tag)
      #rmul(Art_u, Rate) * Tag
      Art_u * Rate
      Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      Art - Art_u
      Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))

  iff

      Can == 1
#+END_SRC

Since =frob= is now frozen, we also provide a method for CDP holder to remove their collateral from a settled =urn=, after =skim= has been called:

#+NAME: shut
#+BEGIN_SRC sol
  function shut(bytes32 ilk) public {
      // TODO: access to bytes
      (uint ink, uint art) = vat.urns(ilk, b32(msg.sender));
      require(art == 0);
      vat.tune(ilk, b32(msg.sender), b32(msg.sender), b32(msg.sender), -int(ink), 0);
  }
#+END_SRC

#+NAME: act-shut
#+BEGIN_SRC act
  behaviour shut of End
  interface shut(bytes32 ilk)

  types

      Vat : address
      Ink : uint256
      Art : uint256
      Gem : uint256

  storage

      vat |-> Vat

  storage Vat

      wards[ACCT_ID]           |-> Can
      urns[ilk][CALLER_ID].ink |-> Ink => 0
      urns[ilk][CALLER_ID].art |-> Art
      gem[ilk][CALLER_ID]      |-> Gem => Gem + Ink

  iff in range uint256

      Gem + Ink

  iff

      Can == 1
      Art == 0
#+END_SRC

** Redemption

A dai holder may exchange their =Vat= dai for =End= dai, which is a one-way process. At this point, the =sin= incurred by the =End= during =skim= is cancelled.

#+NAME: shop
#+BEGIN_SRC sol
  function shop() public {
      uint rad = vat.dai(b32(msg.sender));
      vat.heal(b32(address(this)), b32(msg.sender), int(rad));
      dai[msg.sender] = add(dai[msg.sender], rad);
  }
#+END_SRC

#+NAME: act-shop
#+BEGIN_SRC act
  behaviour shop of End
  interface shop()

  types

      Vat : address
      Rad : uint256
      Sin : uint256

  storage

      vat            |-> Vat
      dai[CALLER_ID] |-> Dai => Dai + Rad

  storage Vat

      wards[ACCT_ID] |-> Can
      dai[CALLER_ID] |-> Rad  => 0
      sin[ACCT_ID]   |-> Sin  => Sin - Rad
      vice           |-> Vice => Vice - Rad
      debt           |-> Debt => Debt - Rad

  iff in range uint256

      Dai + Rad
      Sin - Rad

  iff

      Can == 1
#+END_SRC

For every =Ilk= that they wish to claim, the dai holder calls =pack=, receiving =bag= tokens (/backed asset guarantee tokens/) in the same quantity as the dai they are redeeming:

#+NAME: pack
#+BEGIN_SRC sol
  function pack(bytes32 ilk) public {
      require(bags[ilk][b32(msg.sender)] == 0);
      bags[ilk][b32(msg.sender)] = add(bags[ilk][b32(msg.sender)], dai[msg.sender]);
  }
#+END_SRC

#+NAME: act-pack
#+BEGIN_SRC act
  behaviour pack of End
  interface pack(bytes32 ilk)

  types

      Dai : uint256
      Nul : uint256

  storage

      dai[msg.sender]      |-> Dai
      bags[ilk][CALLER_ID] |-> Nul => Nul + Dai

  iff

      Nul == 0
#+END_SRC

Finally, they may withdraw every =gem= at a rate of \( {\tt fix_i} \) units for one dai, by calling =cash=.

#+NAME: cash
#+BEGIN_SRC sol
  function cash(bytes32 ilk) public {
      vat.flux(ilk, b32(address(this)), b32(msg.sender), int(rmul(bags[ilk][b32(msg.sender)], fixs[ilk])));
      bags[ilk][b32(msg.sender)]  = 0;
      dai[msg.sender]        = 0;
  }
#+END_SRC

#+NAME: act-cash
#+BEGIN_SRC act
  behaviour cash of End
  interface cash(bytes32 ilk)

  types

      Bag : uint256
      Dai : uint256

  storage

      vat                  |-> Vat
      bags[ilk][CALLER_ID] |-> Bag => 0
      dai[CALLER_ID]       |-> Dai => 0

  storage Vat

      wards[ACCT_ID]      |-> Can
      gem[ilk][ACCT_ID]   |-> Gem_end => Gem_end - #rmul(Bag, Fix)
      gem[ilk][CALLER_ID] |-> Gem_lad => Gem_lad + #rmul(Bag, Fix)

  iff in range uint256

      Gem_end - #rmul(Bag, Fix)
      Gem_lad + #rmul(Bag, Fix)

  iff

      Can == 1
#+END_SRC

Irredeemable dai ends up in the =End= due to =dump=. =vent= is there to account for it:

#+BEGIN_SRC sol
  function vent(uint256 rad) public {
      vat.heal(b32(address(this)), b32(address(this)), u2i(rad));
  }
#+END_SRC

#+BEGIN_SRC act
  behaviour vent of End
  interface vent(uint256 rad)

  types

      Vat  : address VatLike
      Can  : uint256
      Dai  : uint256
      Sin  : uint256
      Debt : uint256
      Vice : uint256

  storage

      vat |-> Vat

  storage Vat

      Can[ACCT_ID] |-> Can
      dai[ACCT_ID] |-> Dai  => Dai  - rad
      sin[ACCT_ID] |-> Sin  => Sin  - rad
      debt         |-> Debt => Debt - rad
      vice         |-> Vice => Vice - rad

  iff

      Can == 1

  iff in range uint256

      Dai  - rad
      Sin  - rad
      Debt - rad
      Vice - rad
#+END_SRC

* TODO NFT Settlement Modules

NFTs need to be dealt with separately, in a manner similar to the collateral which is already undergoing liquidation at the time of cage.

* Tests

#+NAME: solidity-test-skeleton
#+BEGIN_SRC sol :tangle "src/cage.t.sol" :exports none
  // cage.t.sol -- global settlement tests

  // <<license>>

  pragma solidity >=0.5.0;

  import "ds-test/test.sol";
  import "ds-token/token.sol";

  import {Vat}  from 'dss/tune.sol';
  import {Pit}  from 'dss/frob.sol';
  import {Cat}  from 'dss/bite.sol';
  import {Vow}  from 'dss/heal.sol';
  import {GemJoin} from 'dss/join.sol';
  import {GemMove, DaiMove} from 'dss/move.sol';
  import {End}  from './cage.sol';

  contract EndTest is DSTest {
      Vat   vat;
      End   end;
      Pit   pit;
      Vow   vow;
      Cat   cat;

      DSToken gold;

      GemJoin gemA;
      GemMove gemM;
      DaiMove daiM;

      bytes32 urn1;
      bytes32 urn2;

      <<test-helper>>

      <<test-setUp>>

      <<test-cage-basic>>

      <<test-cage-collateralised>>

      <<test-cage-undercollateralised-cdp-parity>>

      // <<test-cage-undercollateralised-dai-parity-toll>>

      // <<test-cage-undercollateralised-dai-parity-fold>>
  }
#+END_SRC

** Setup

Some helper functions for the test contract:

#+NAME: test-helper
#+BEGIN_SRC sol
  uint constant ONE = 10 ** 27;

  function ray(uint wad) internal pure returns (uint) {
      return wad * 10 ** 9;
  }
  function rad(uint wad) internal pure returns (uint) {
      return wad * ONE;
  }
  function rmul(uint x, uint y) internal pure returns (uint z) {
      z = x * y;
      require(y == 0 || z / y == x);
      z = z / ONE;
  }
  function gem(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      return vat.gem(ilk, urn) / 10 ** 27;
  }
  function ink(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      (uint ink_, uint art_) = vat.urns(ilk, urn); art_;
      return ink_;
  }
  function art(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      (uint ink_, uint art_) = vat.urns(ilk, urn); ink_;
      return art_;
  }
#+END_SRC

We deploy the necessary components of the system for testing:

#+NAME: test-setUp
#+BEGIN_SRC sol
  function setUp() public {
      vat = new Vat();

      pit = new Pit(address(vat));
      vat.rely(address(pit));

      vow = new Vow();
      vow.file("vat", address(vat));
      vat.rely(address(vow));

      cat = new Cat(address(vat));
      vat.rely(address(cat));
      vow.rely(address(cat));

      end = new End();
      end.file("vat", address(vat));
      end.file("pit", address(pit));
      end.file("cat", address(cat));
      end.file("vow", address(vow));
      vat.rely(address(end));
      pit.rely(address(end));
      cat.rely(address(end));

      gemM = new GemMove(address(vat), "gold");
      vat.rely(address(gemM));
      daiM = new DaiMove(address(vat));
      vat.rely(address(daiM));

      gold = new DSToken("GEM");
      gold.mint(20 ether);

      vat.init("gold");
      gemA = new GemJoin(address(vat), "gold", address(gold));

      // 1 gold = 6 dai and liquidation ratio is 200%
      pit.file("gold", "spot", ray(3 ether));
      pit.file("gold", "line", 1000 ether);
      pit.file("Line", uint(1000 ether));

      gold.approve(address(gemA));
      gold.approve(address(vat));

      vat.rely(address(pit));
      vat.rely(address(gemA));
  }
#+END_SRC

The first basic test ensures that =end.cage(hump)= is able to run and sets the liveness flags correctly:

#+NAME: test-cage-basic
#+BEGIN_SRC sol
  function test_cage_basic() public {
      assert(end.live() == 1);
      assert(vat.live() == 1);
      assert(pit.live() == 1);
      assert(cat.live() == 1);
      end.cage(0);
      assert(end.live() == 0);
      assert(vat.live() == 0);
      assert(pit.live() == 0);
      assert(cat.live() == 0);
  }
#+END_SRC

** Testing the case with no undercollateralised CDPs

The next test simulates a basic global settlement scenario with one CDP which is not undercollateralised. We follow the computations for \( {\tt tag } \) and \( {\tt fix } \) that were proposed earlier. With only one collateral type and no system debt, they simplify to:

\[
{\tt tag} = {\tt fix} = \frac{1}{p_i}
\]

We assume that the price of ="gold"= is now 5 dai, so \( {\tt tag} \) and \( {\tt fix} \) will both be \( \frac{1}{5} \).

#+NAME: test-cage-collateralised
#+BEGIN_SRC sol
  function test_cage_collateralised() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      pit.frob("gold", urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      uint tag = ONE / 5;
      uint fix = ONE / 5;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(15 ether));

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), rad(15 ether));

      // CDP closing
      end.shut("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      gemA.exit(urn1, address(this), 7 ether);

      // dai redemption
      end.shop();

      // global checks:
      // no need for vent
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(vat.dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      gemA.exit(urn1, address(this), 3 ether);

      assertEq(gem("gold", bytes32(bytes20(address(end)))), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

** Testing the case with CDP parity

We test the case where there are two CDPs, one of the CDP is undercollateralised, and we ensure CDP parity (at the expense of dai parity). Suppose the price of ="gold"= falls as low as 2 dai, then \( {\tt tag} \) is \( \frac{1}{2} \) while \( {\tt fix} \) is given by equation \ref{eq:fixcdpparity}:

\[
{\tt fix} = \frac{17}{36} = 0.472 \ldots
\]

#+NAME: test-cage-undercollateralised-cdp-parity
#+BEGIN_SRC sol
  function test_cage_undercollateralised_cdp_parity() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      pit.frob("gold", urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // make a second CDP:
      urn2 = bytes32(uint256(bytes32(bytes20(address(this)))) + 1);
      gemA.join(urn2, 1 ether);
      pit.frob("gold", urn2, 1 ether, 3 ether);
      // this urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      // CDP holders settled at price of 2
      uint tag = ONE / 2;
      // DAI holders get ~0.944
      uint fix = (17 * ONE) / 36;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);
      end.skim("gold", urn2);

      // local checks
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 2.5 ether);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(18 ether));

      // global checks
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      end.shut("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 2.5 ether);
      gemA.exit(urn1, address(this), 2.5 ether);

      // first dai redemption
      end.shop();

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(vat.dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 15 ether));
      gemA.exit(urn1, address(this), rmul(fix, 15 ether));

      // gather remaining dai into urn1
      daiM.move(urn2, urn1, 3 ether);
      // second dai redemption
      end.shop();

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(vat.dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 3 ether));
      gemA.exit(urn1, address(this), rmul(fix, 3 ether));

      assertEq(gem("gold", bytes32(bytes20(address(end)))), 0);
      // some dust remains in the adapter because of rounding:
      assertTrue(gold.balanceOf(address(gemA)) < 2);
  }
#+END_SRC

** TODO Testing the case with dai parity

*** TODO socialising proportionally to collateral

We now test the case when there are two CDPs, one of which is undercollateralised, but such that the =Ilk= as a whole is well collateralised. Suppose that the price of ="gold"= falls as low as 2 dai, applying our formulas for \( {\tt tag } \) and \( {\tt fix } \) gives:

\begin{gather*}
{\tt tag } = \frac{8}{17} \\
{\tt fix } = \frac{1}{2}
\end{gather*}

#+NAME: test-cage-undercollateralised-dai-parity-toll
#+BEGIN_SRC sol
  function test_cage_undercollateralised() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      pit.frob("gold", urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // make a second CDP:
      urn2 = bytes32(uint256(bytes32(bytes20(address(this)))) + 1);
      gemA.join(urn2, 1 ether);
      pit.frob("gold", urn2, 1 ether, 3 ether);
      // this urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      uint tag = (8 * ONE) / 17;
      uint fix = ONE / 2;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);
      end.skim("gold", urn2);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 1010101);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(18 ether));

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      end.shut("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 202020);
      assertEq(ink("gold", urn2), 0);
      assertEq(gem("gold", urn2), 0);

      end.shop();

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      end.pack("gold");
      assertEq(gem("gold", bytes32(bytes20(address(end)))), 30303);
      end.cash("gold");

      // local checks:
      assertEq(vat.dai(urn1), 0);
      assertEq(gem("gold", urn1), 60606 ether);

      // gather remaining dai into urn1
      daiM.move(urn2, urn1, 3 ether);

      end.shop();

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      assertEq(gem("gold", bytes32(bytes20(address(end)))), 40404);
      end.cash("gold");

      // local checks:
      assertEq(vat.dai(urn1), 0);
      assertEq(gem("gold", urn1), 50505 ether);
  }
#+END_SRC
