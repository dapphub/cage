#+TITLE: `cage`
#+DATE: <2019-01-24 Thu>
#+AUTHOR:
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+OPTIONS: html-postamble:nil tex:mathjax
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+PROPERTY: header-args :results output :exports both :noweb strip-export :tangle no :mkdirp yes
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./body.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./theme.css"/>
#+HTML_HEAD_EXTRA: <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="/home/lev/src/MathJax/MathJax.js?config=TeX-AMS_HTML-full"><\/script>')</script>

#+OPTIONS:
# Local Variables:
# org-confirm-babel-evaluate: nil
# org-babel-exp-code-template: "#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC"
# End:

#+NAME: solidity-skeleton
#+BEGIN_SRC sol :tangle "src/end.sol" :exports none
  /// end.sol -- global settlement engine

  // <<license>>

  pragma solidity >=0.5.0;
  pragma experimental ABIEncoderV2;

  contract VatLike {
      struct Ilk {
          uint256 Art;
          uint256 rate;
          uint256 spot;
          uint256 line;
          uint256 dust;
      }
      struct Urn {
          uint256 ink;
          uint256 art;
      }
      function sin(address) public view returns (uint);
      function dai(address) public view returns (uint);
      function ilks(bytes32 ilk) public returns (Ilk memory);
      function urns(bytes32 ilk, address urn) public returns (Urn memory);
      function debt() public returns (uint);
      function move(address src, address dst, uint256 rad) public;
      function flux(bytes32 ilk, address src, address dst, uint256 rad) public;
      function tune(bytes32 i, address u, address v, address w, int256 dink, int256 dart) public;
      function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) public;
      function heal(uint256 rad) public;
      function suck(address u, address v, uint256 rad) public;
      function cage() public;
  }
  contract CatLike {
      struct Ilk {
          address flip;  // Liquidator
          uint256 chop;  // Liquidation Penalty   [ray]
          uint256 lump;  // Liquidation Quantity  [rad]
      }
      function ilks(bytes32) public returns (Ilk memory);
      function cage() public;
  }
  contract VowLike {
      function Joy() public view returns (uint);
      function Awe() public view returns (uint);
      function heal(uint256 rad) public;
      function kiss(uint256 rad) public;
      function cage() public;
      function loot() public;
  }
  contract Flippy {
      struct Bid {
          uint256 bid;
          uint256 lot;
          address guy;
          uint48  tic;
          uint48  end;
          address urn;
          address gal;
          uint256 tab;
      }
      function cage() public;
      function bids(uint id) public view returns (Bid memory);
      function yank(uint id) public;
  }

  contract PipLike {
      function read() public view returns (bytes32);
  }

  contract Spotty {
      struct Ilk {
          PipLike pip;
          uint256 mat;
      }
      function ilks(bytes32) public view returns (Ilk memory);
  }


    contract End {

        // --- Auth ---
        <<auth>>

        // --- Data ---
        <<data>>

        // --- Init ---
        <<init>>

        // --- Math ---
        <<math>>

        // --- Administration ---
        <<file-address>>
        <<file-uint256>>

        // --- Settlement ---
        <<cage>>

        <<cage-ilk>>

        <<skip>>

        <<skim>>

        <<bail>>

        <<free>>

        <<thaw>>

        <<flow>>

        <<shop>>

        <<pack>>

        <<cash>>
    }
#+END_SRC

#+NAME: act-skeleton
#+BEGIN_SRC act :tangle "act/end.act" :exports none
   // <<license>>

   <<act-file-address>>

   <<act-file-uint256>>

   <<act-cage>>

   <<act-cage-ilk>>

   <<act-skip>>

   <<act-skim>>

   <<act-bail>>

   <<act-free>>

   <<act-thaw>>

   <<act-flow>>

   <<act-shop>>

   <<act-pack>>

   <<act-cash>>
#+END_SRC

* License
#+NAME: license
#+BEGIN_SRC fundamental
  Copyright (C) 2018 Rain <rainbreak@riseup.net>
  Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC


* Introduction
=`cage`= is the most complex mechanism in =dss=. This is because it must alter the behaviour of almost every component of the system and it must perform under a variety of possible (under)collateralisation regimes. In particular, there are a number of key properties, such as dai and CDP parity, or the lack of race conditions, which should be guaranteed even in edge cases, e.g. in the presence of CDPs which have become less than 100% collateralised. This means that a relatively complex calculation must be performed to determine the correct rates for collateral redemption by dai and CDP owners. Since in some edge cases it will not be possible to satisfy all desirable properties at once, a choice must be made about which to prioritise.

The procedure for =cage= looks roughly as follows:
1. Beforehand, the =End= contract is configured with the addresses of the =Vat=, =Vow=, =Cat=, and the price feed coordinator =Spot=. A suitable cooldown period =wait= is chosen. An appropriate entity which will be allowed to initiate global settlement is added as an owner of the =End=.
2. When the time comes to globally settle the system, the top-level =cage= method is called by an authorised party, which puts all system components into post-=cage= mode, and starts the cooldown timer. All subsequent steps are completely permissionless and can be triggered by anyone.
3. For each collateral type, the per-=Ilk= =cage= method is called. This fetches the feed price from the =spot= to set the =tags=, which are the prices at which all CDPs of that collateral type will be settled.
4. CDPs that are not undercollateralised can immediately be settled with =skim=, and the collateral can be withdrawn by their owner with =free=.
5. Any CDPs which are _undercollateralised_, i.e. whose debt is greater in value than their collateral as judged by the =tag=, are settled by calling =bail=.
6. Any ongoing collateral auctions that have not yet raised the dai to cover their debt are blocked from finalising, and are reversed by calling =skip=, returning the collateral and debt to the original CDP.
7. Once the cooldown timer has finished, =thaw= and =flow= are called to fix the dai redemption rates, called =fixs=. It is assumed that all undercollateralised positions have been =bail=ed by this point, and all deficit auctions have been =skip=ped, i.e. we assume that during the cooldown period steps 5 and 6 were completed.
8. dai holders can redeem the collateral they are entitled to by going through =shop=, =pack=, and =cash=.

* Setup
We will require safe addition, subtraction, and multiplication, =Ray= fixed-point multiplication and division, and =min=:
#+NAME: math
#+BEGIN_SRC sol
  function add(uint x, uint y) internal pure returns (uint z) {
      z = x + y;
      require(z >= x);
  }
  function sub(uint x, uint y) internal pure returns (uint z) {
      require((z = x - y) <= x);
  }
  function mul(uint x, uint y) internal pure returns (uint z) {
      require(y == 0 || (z = x * y) / y == x);
  }
  uint constant RAY = 10 ** 27;
  function rmul(uint x, uint y) internal pure returns (uint z) {
      z = mul(x, y) / RAY;
  }
  function rdiv(uint x, uint y) internal pure returns (uint z) {
      z = mul(x, RAY) / y;
  }
  function min(uint x, uint y) internal pure returns (uint z) {
      if (x > y) { z = y; } else { z = x; }
  }
#+END_SRC

The contract that coordinates global settlement is called the =End=. The storage layout of the =End= is as follows:
#+NAME: data
#+BEGIN_SRC sol
  mapping (address => uint) public wards;

  VatLike  public vat;
  CatLike  public cat;
  VowLike  public vow;
  Spotty   public spot;

  uint256  public live;
  uint256  public wait;
  uint256  public when;
  uint256  public debt;

  mapping (address => uint256)                      public dai;
  mapping (bytes32 => uint256)                      public tags;
  mapping (bytes32 => uint256)                      public gaps;
  mapping (bytes32 => uint256)                      public fixs;
  mapping (bytes32 => uint256)                      public arts;
  mapping (bytes32 => mapping (address => uint256)) public bags;
#+END_SRC

The =End= uses the same multiowner auth model as the other =dss= contracts:
#+NAME: auth
#+BEGIN_SRC sol
  function rely(address guy) public auth { wards[guy] = 1; }
  function deny(address guy) public auth { wards[guy] = 0; }
  modifier auth { require(wards[msg.sender] == 1); _; }
#+END_SRC

The constructor simply sets the creating account as owner and marks the system as =live=, i.e. uncaged:
#+NAME: init
#+BEGIN_SRC sol
  constructor() public {
      wards[msg.sender] = 1;
      live = 1;
  }
#+END_SRC

The target contracts of the =End= can be modified by owners in-flight:
#+NAME: file-address
#+BEGIN_SRC sol
  function file(bytes32 what, address data) public auth {
      if (what == "vat") vat = VatLike(data);
      if (what == "cat") cat = CatLike(data);
      if (what == "vow") vow = VowLike(data);
      if (what == "spot") spot = Spotty(data);
  }
#+END_SRC

#+NAME: act-file-address
#+BEGIN_SRC act
  behaviour file of End
  interface file(bytes32 what, address data)

  types

      Vat_was  : address
      Cat_was  : address
      Vow_was  : address
      Spot_was : address

  storage

      wards[CALLER_ID] |-> Can
      Vat  |-> Vat_was => #if what == #string2Word("vat")  #then data else Vat_was
      Cat  |-> Cat_was => #if what == #string2Word("cat")  #then data else Cat_was
      Vow  |-> Vow_was => #if what == #string2Word("vow")  #then data else Vow_was
      Spot  |-> Spot_was => #if what == #string2Word("spot")  #then data else Spot_was

  iff

      Can == 1
#+END_SRC

The cooldown period can also be configured:
#+NAME: file-uint256
#+BEGIN_SRC sol
  function file(bytes32 what, uint256 data) public auth {
      if (what == "wait") wait = data;
  }
#+END_SRC

#+NAME: act-file-uint256
#+BEGIN_SRC act :exports none
  // TODO
#+END_SRC

* The =cage= process
First, the top-level =cage= method is called, which sets the =live= flag to zero and initiates =cage= in the other relevant system modules:
#+NAME: cage
#+BEGIN_SRC sol
  function cage() public auth {
      require(live == 1);
      live = 0;
      when = now;
      vat.cage();
      cat.cage();
      vow.cage();
  }
#+END_SRC

#+NAME: act-cage
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour cage of End
  interface cage(uint256 dump)

  types

      Can         : uint256
      Vat         : address
      Cat         : address
      Vow         : address
      Can_vat     : uint256
      Can_cat     : uint256
      Can_vow     : uint256
      Live        : uint256
      Vat_live    : uint256
      Cat_live    : uint256
      Vow_live    : uint256
      Ssin        : uint256
      Ash         : uint256
      Dai         : uint256
      Sin         : uint256
      Vice        : uint256
      Debt        : uint256
      Dai_end     : uint256
      Can_vat_vow : uint256

  storage

      wards[CALLER_ID] |-> Can
      cat              |-> Cat
      vow              |-> Vow
      live             |-> Live => 0

  storage Cat

      wards[ACCT_ID]   |-> Can_cat
      live             |-> Cat_live => 0

  storage Vow

      wards[ACCT_ID]   |-> Can_vow
      live             |-> Vow_live => 0
      Sin              |-> Ssin
      Ash              |-> Ash
      Hump             |-> Hump

  storage Vat

      wards[ACCT_ID] |-> Can_vat
      wards[Vow]     |-> Can_vat_vow
      live           |-> Vat_live => 0
      dai[Vow]       |-> Dai      => Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray \
                                          - #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)
      sin[Vow]       |-> Sin      => Sin  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      vice           |-> Vice     => Vice - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      debt           |-> Debt     => Debt - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      dai[ACCT_ID]   |-> Dai_end  => Dai_end \
                                          + #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)

  iff in range uint256

      Sin / #Ray - Ssin
      (Sin / #Ray - Ssin) - Ash
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Sin  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Vice - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Debt - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Hump * dump
      Dai_end + #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)

  iff

      Live        == 1
      Can         == 1
      Can_vat     == 1
      Can_cat     == 1
      Can_vow     == 1
      Can_vat_vow == 1
#+END_SRC

Next, the per-=Ilk= =cage= method is called, which fetches the collateral price from the `spot` and sets the global settlement flag in the collateral auction contract:

#+NAME: cage-ilk
#+BEGIN_SRC sol
  function cage(bytes32 ilk) public auth {
      require(live == 0);
      require(tags[ilk] == 0);
      tags[ilk] = rdiv(RAY, uint(spot.ilks(ilk).pip.read()));
      Flippy(cat.ilks(ilk).flip).cage();
  }
#+END_SRC

#+NAME: act-cage-ilk
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour cage-ilk of End
  interface cage(bytes32 ilk, uint256 tag, uint256 fix)

  types

      Can  : uint256
      Live : uint256
      Cat  : address CatLike
      Flip : address Flippy

  storage

      wards[CALLER_ID] |-> Can
      live             |-> Live
      tags[ilk]        |-> _ => tag
      fixs[ilk]        |-> _ => fix

  storage Cat

      ilks[ilk].flip   |-> Flip

  storage Flip

      wards[CALLER_ID] |-> Can_flip
      live             |-> Flip_live => 0

  iff

      Can      == 1
      Live     == 0
      Can_flip == 1
#+END_SRC

At this point, any outstanding `Flip` auctions that have not yet raised their target amount of dai can be cancelled ("yanked") by calling the public method =skip(uint id)=. When an auction is yanked, the collateral and debt are assigned back to the original CDP, which will then be settled as if it had not yet been liquidated, and the highest bidder is refunded their dai. Auctions that have already raised their target amount of dai are allowed to proceed and can receive further =dent= bids and settle as normal.
#+NAME: skip
#+BEGIN_SRC sol
  function skip(bytes32 ilk, uint256 id) public {
      require(live == 0);

      address flip = cat.ilks(ilk).flip;
      VatLike.Ilk memory i   = vat.ilks(ilk);
      Flippy.Bid  memory bid = Flippy(flip).bids(id);

      Flippy(flip).yank(id);
      vat.suck(address(vow), address(vow), bid.tab);
      vat.grab(ilk, bid.urn, address(this), address(vow), int(bid.lot), int(bid.tab / i.rate));
  }
#+END_SRC

#+NAME: act-skip
#+BEGIN_SRC act :exports none
  behaviour skip of End
  interface skip(bytes32 ilk, uint256 id)

  // TODO
#+END_SRC

For the purposes of the upcoming calculation, we will assume that all yankable auctions have been yanked. In particular, when the cooldown period has elapsed and =flow= is executed, we will assume that the outstanding =Art= for each =Ilk= has been updated to include all CDPs that were previously in liquidation that had not yet raised enough dai to cover their debt.

** Interlude: the =fix= computation

The =fix= represents the quantity of =gem= that a user will be able to redeem for one dai. We now describe the procedure by which it should be computed. In the following calculation, for notational simplicity, the appropriate operations for fixed point units are implicit, e.g. \( {\tt art_{iu}} \cdot {\tt rate_i} \) is the outstanding dai debt of CDP =u=, etc.

In this case, the total quantity of dai that must be redeemable through =End= is the dai supply once all dai surplus in the =Vow= has been removed. We will denote this quantity by \( debt^\prime \).

The first priority is to ensure that there is no race condition. That is to say, that with the \( {\tt fix_i}\) and \({\tt tag_i} \) that we chosen, every dai holder will be able to redeem the same quantity of =gem=, regardless of when they interact with the =End=. Let \( {\tt war_{iu}} \) denote the amount of collateral of type =i= taken from the urn =u= that will go to dai redemption. Then this property can be expressed as:

\[
\sum_u {\tt war_{iu}} = {\tt fix_i} \cdot {\tt debt}^\prime
\]

We shall call this the /no-race property/. Setting \( {\tt war_{iu}} \) to be \( \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i }) \), where \( {\tt tag_i} \) is the /CDP settlement rate/, we can solve for \( {\tt fix_i } \):

\[
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt}^\prime}
\]

Similarly, it is desirable for CDPs to be settled at the market value of their collateral, i.e. that:

\[
{\tt tag_i } = \frac{1}{p_i}
\]

We call this the /CDP parity property/.

Another desirable feature is for all =gem= redeemable for one dai to be worth one dollar:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1
\]

We call this the /dai parity property/. As we shall see, it might not be satisfied if the system is in deficit.

**** In the absence of undercollateralised positions

Consider the case where no CDPs are undercollateralised, i.e. that for all =u=, \( {\tt art_{iu}} \cdot {\tt rate_i} \geq {\tt ink_{iu}} \cdot p_{{\tt i}} \). Then we can satisfy all three constraints simultaneously simply by setting \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \):

\[
{\tt fix_i} = \frac{{\tt rate_i} \cdot {\tt tag_i } \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt rate_i} \cdot {\tt Art_i}}{p_{{\tt i}}\cdot({\tt debt}^\prime - {\tt hump \cdot dump })}
\]

Writing \( {\tt pump} := \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump}\cdot{\tt dump}} \) for the /=hump= burn multiplier/:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = \frac{\sum_i {\tt rate_i} \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump \cdot dump }} = {\tt pump}
\]

from which it is clear that we could use \( {\tt dump } = 0 \) and satisfy the no-race property and both parity properties.

**** In the presence of undercollateralised positions

***** Ensuring CDP parity:

Now if some CDPs had been undercollateralised, we would have had instead:

\begin{equation}
\label{eq:fixcdpparity}
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, \frac{{\tt art_{iu}} \cdot {\tt rate_i}}{p_{{\tt i}}})}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i}}{p_{{\tt i}}({\tt debt}^\prime - {\tt hump \cdot dump })}
\end{equation}

and the value redeemable from one dai would be:

\begin{align*}
\sum_i {\tt fix_i} \cdot p_{{\tt i}} & = \frac{\sum_i {\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i} }{{\tt debt}^\prime - {\tt hump \cdot dump }} \\
                                     & = \frac{{\tt debt} - {\tt Gap}}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\end{align*}

where \( {\tt gap_i} := \sum_u \mathrm{max} (0, {\tt art_{iu}} \cdot {\tt rate_i} - p_{{\tt i}} \cdot {\tt ink_i}) \) and \( {\tt Gap} := \sum_i {\tt gap_i} \), are the per =Ilk= and global gross negative CDP equity, respectively. Thus, though we have ensured the no-race and CDP parity properties, we have not necessarily ensured dai parity. However, if =hump= is large enough relative to =Gap=, it may be possible to ensure that the above expression equals one, solely by increasing =dump=.

***** Ensuring dai parity:

We might also be able to set \( {\tt tag_i } \) and \( {\tt fix_i } \) so as to guarantee dai parity. We could start by postulating that for all \( {\tt i} \):

\begin{equation}
\label{eq:fixdaiparity}
{\tt fix_i} \cdot p_{{\tt i}} = \frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt}^\prime}
\end{equation}

which will ensure that \( \sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1 \) due to the fundamental equation of dai.

It remains to choose the \( {\tt tag_i} \) such that losses from undercollateralised CDPs of =Ilk= =i= are socialised across all CDPs of the =Ilk=. This means that we will only be able to guarantee parity in the case that each =Ilk= is on aggregate not undercollateralised.

When socialising proportionally to debt, e have to solve the following for \( {\tt tag_i} \):

\begin{equation}
\label{eq:tagdaiparity-debt}
\frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt}^\prime} = p_{{\tt i}} \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\end{equation}

This is a linear optimisation problem without a closed-form solution, which can be solved numerically by linear complementarity methods. It is easy to see that a solution exists precisely when

\[
{\tt Art_i} \cdot {\tt rate_i} \leq {\tt Ink_i} \cdot p_{\tt i} \cdot {\tt pump}
\]

i.e. the =Ilk= as a whole is not undercollateralised (after adjusting for the =dump=). Note also that when there are no undercollateralised CDPs in the =Ilk= =i= and with \( {\tt dump = 0} \), equation \ref{eq:tagdaiparity-debt} can be solved with \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \), so this generalises our previous solution. Note that there is again a choice of how much of the =hump= to burn, where if more of the =hump= is burned then a smaller loss is imposed on CDP holders.

**** Summary of parity conditions
To summarise, when there are undercollateralised CDPs, the options are:
***** Ensure CDP parity:
set \( {\tt tag_i} = \frac{1}{p_i} \) and \( {\tt fix_i} \) according to formula \ref{eq:fixcdpparity}. It may still be possible to also ensure dai parity with =dump= if the =hump= is large enough.
***** Ensure DAI parity:
in both cases, set =dump = 1= and \( {\tt fix_i} \) according to formula \ref{eq:fixdaiparity}.
****** by socialising proportionally to debt
Set \( {\tt tag_i} \) according to formula \ref{eq:tagdaiparity-debt}.

There are two additional redistribution methods that are not considered here:
****** by socialising proportionally to equity
****** by socialising proportionally to collateral

**** In the presence of an undercollateralised =Ilk=

A different calculation is necessary if there is an =Ilk= which is undercollateralised in aggregate, i.e. has \( {\tt Art_i} \cdot {\tt rate_i} \lt {\tt gap_i} \), and parity is desired. In that case, it is necessary to set the \( {\tt fix_i} \) in such a way as to socialise the losses from the undercollateralised =Ilk= across other collateral types. TODO: This calculation is TBA.

** CDP Settlement
Once =tag_i= has been provided, individual CDPs can be processed with =skim=, settling the position at the price implied by =tag_i=. This method is public, and both CDP holders and dai holders are incentivised to call it: the former in order to withdraw their remaining collateral, and the latter in order to make collateral available for redemption.
#+NAME: skim
#+BEGIN_SRC sol
  function skim(bytes32 ilk, address urn) public {
      require(tags[ilk] != 0);

      VatLike.Ilk memory i = vat.ilks(ilk);
      VatLike.Urn memory u = vat.urns(ilk, urn);

      uint war = rmul(rmul(u.art, i.rate), tags[ilk]);
      // redundant check:
      require(u.ink >= war);
      arts[ilk] = add(arts[ilk], u.art);

      vat.grab(ilk, urn, address(this), address(vow), -int(war), -int(u.art));
  }
#+END_SRC

#+NAME: act-skim
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour skim of End
  interface skim(bytes32 ilk, bytes32 urn)

  types

      Tag    : uint256
      Vat    : address
      Can    : uint256
      Rate   : uint256
      Ink_u  : uint256
      Art_u  : uint256
      Ink    : uint256
      Art    : uint256
      Gem    : uint256
      Sin    : uint256
      Vice   : uint256

  storage

      tags[ilk] |-> Tag
      vat       |-> Vat

  storage Vat

      wards[ACCT_ID]     |-> Can
      ilks[ilk].rate     |-> Rate
      urns[ilk][urn].ink |-> Ink_u => Ink_u - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      urns[ilk][urn].art |-> Art_u => 0
      ilks[ilk].Ink      |-> Ink   => Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      ilks[ilk].Art      |-> Art   => Art - Art_u
      gem[ilk][ACCT_ID]  |-> Gem   => Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      sin[ACCT_ID]       |-> Sin   => Sin - Rate * Art_u
      vice               |-> Vice  => Vice - Rate * Art_u

  iff in range uint256

      Ink_u * #rmul(#rmul(Art_u, Rate), Tag)
      #rmul(Art_u, Rate) * Tag
      Art_u * Rate
      Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      Art - Art_u
      Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))

  iff

      Can == 1
#+END_SRC

For undercollateralised CDP, we must instead call =bail=:

#+NAME: bail
#+BEGIN_SRC sol
  function bail(bytes32 ilk, address urn) public {
      require(tags[ilk] != 0);

      VatLike.Ilk memory i = vat.ilks(ilk);
      VatLike.Urn memory u = vat.urns(ilk, urn);

      uint war = rmul(rmul(u.art, i.rate), tags[ilk]);

      // redundant check:
      require(u.ink < war);
      arts[ilk] = add(arts[ilk], u.art);
      gaps[ilk] = add(gaps[ilk], sub(war, u.ink));

      vat.grab(ilk, urn, address(this), address(vow), -int(u.ink), -int(u.art));
  }
#+END_SRC

#+NAME: act-bail
#+BEGIN_SRC act :exports none
  // TODO
#+END_SRC

Since =frob= is now frozen, we also provide a method for CDP holder to remove their collateral from a settled =urn=, after =skim= has been called:

#+NAME: free
#+BEGIN_SRC sol
  function free(bytes32 ilk) public {
      VatLike.Urn memory u = vat.urns(ilk, msg.sender);
      require(u.art == 0);
      vat.grab(ilk, msg.sender, msg.sender, address(vow), -int(u.ink), 0);
  }
#+END_SRC

#+NAME: act-free
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour free of End
  interface free(bytes32 ilk)

  types

      Vat : address
      Ink : uint256
      Art : uint256
      Gem : uint256

  storage

      vat |-> Vat

  storage Vat

      wards[ACCT_ID]           |-> Can
      urns[ilk][CALLER_ID].ink |-> Ink => 0
      urns[ilk][CALLER_ID].art |-> Art
      gem[ilk][CALLER_ID]      |-> Gem => Gem + Ink

  iff in range uint256

      Gem + Ink

  iff

      Can == 1
      Art == 0
#+END_SRC

** Post cooldown processing
#+NAME: thaw
#+BEGIN_SRC sol
  function thaw() public {
      require(now >= when + wait);
      require(debt == 0);
      require(vow.Joy() == 0);
      debt = vat.debt();
  }
#+END_SRC

#+NAME: act-thaw
#+BEGIN_SRC act :exports none
  // TODO
#+END_SRC

#+NAME: flow
#+BEGIN_SRC sol
  function flow(bytes32 ilk) public {
      require(debt != 0);
      require(fixs[ilk] == 0);

      VatLike.Ilk memory i = vat.ilks(ilk);
      uint256 wad = rmul(rmul(add(i.Art, arts[ilk]), i.rate), tags[ilk]);
      fixs[ilk] = rdiv(mul(sub(wad, gaps[ilk]), RAY), debt);
  }
#+END_SRC

#+NAME: act-flow
#+BEGIN_SRC act :exports none
  // TODO
#+END_SRC

** Redemption

A dai holder may exchange their =Vat= dai for =End= dai, which is a one-way process. At this point, the =sin= incurred by the =End= during =skim= is cancelled.

#+NAME: shop
#+BEGIN_SRC sol
  function shop(uint256 wad) public {
      require(debt != 0);
      vat.move(msg.sender, address(vow), mul(wad, RAY));
      vow.heal(mul(wad, RAY));
      dai[msg.sender] = add(dai[msg.sender], wad);
  }
#+END_SRC

#+NAME: act-shop
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour shop of End
  interface shop(uint256 wad)

  types

      Vat : address
      Sin : uint256

  storage

      vat            |-> Vat
      dai[CALLER_ID] |-> Dai => Dai + Wad

  storage Vat

      wards[ACCT_ID] |-> Can
      dai[CALLER_ID] |-> Rad  => 0
      sin[ACCT_ID]   |-> Sin  => Sin - wad * #Ray
      vice           |-> Vice => Vice - wad * #Ray
      debt           |-> Debt => Debt - wad * #Ray

  iff in range uint256

      Dai + wad * #Ray
      Sin - wad * #Ray

  iff

      Can == 1
#+END_SRC

For every =Ilk= that they wish to claim, the dai holder calls =pack=, receiving =bag= tokens (/backed asset guarantee tokens/) in the same quantity as the dai they are redeeming:

#+NAME: pack
#+BEGIN_SRC sol
  function pack(bytes32 ilk) public {
      require(bags[ilk][msg.sender] == 0);
      bags[ilk][msg.sender] = dai[msg.sender];
  }
#+END_SRC

#+NAME: act-pack
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour pack of End
  interface pack(bytes32 ilk)

  types

      Dai : uint256
      Nul : uint256

  storage

      dai[msg.sender]      |-> Dai
      bags[ilk][CALLER_ID] |-> Nul => Nul + Dai

  iff

      Nul == 0
#+END_SRC

Finally, they may withdraw every =gem= at a rate of \( {\tt fix_i} \) units for one dai, by calling =cash=.

#+NAME: cash
#+BEGIN_SRC sol
  function cash(bytes32 ilk) public {
      require(fixs[ilk] != 0);
      vat.flux(ilk, address(this), msg.sender, rmul(bags[ilk][msg.sender], fixs[ilk]));
      bags[ilk][msg.sender]  = 0;
      dai[msg.sender]        = 0;
  }
#+END_SRC

#+NAME: act-cash
#+BEGIN_SRC act :exports none
  // TODO update
  behaviour cash of End
  interface cash(bytes32 ilk)

  types

      Bag : uint256
      Dai : uint256

  storage

      vat                  |-> Vat
      bags[ilk][CALLER_ID] |-> Bag => 0
      dai[CALLER_ID]       |-> Dai => 0

  storage Vat

      wards[ACCT_ID]      |-> Can
      gem[ilk][ACCT_ID]   |-> Gem_end => Gem_end - #rmul(Bag, Fix)
      gem[ilk][CALLER_ID] |-> Gem_lad => Gem_lad + #rmul(Bag, Fix)

  iff in range uint256

      Bag * Fix
      Gem_end - #rmul(Bag, Fix)
      Gem_lad + #rmul(Bag, Fix)

  iff

      Can == 1
#+END_SRC

* Tests

#+NAME: solidity-test-skeleton
#+BEGIN_SRC sol :tangle "src/end.t.sol" :exports none
  // end.t.sol -- global settlement tests

  // <<license>>

  pragma solidity >=0.5.0;

  import "ds-test/test.sol";
  import "ds-token/token.sol";
  import "ds-value/value.sol";

  import {Vat}  from 'dss/vat.sol';
  import {Cat}  from 'dss/cat.sol';
  import {Vow}  from 'dss/vow.sol';
  import {Flipper} from 'dss/flip.sol';
  import {Flapper} from 'dss/flap.sol';
  import {Flopper} from 'dss/flop.sol';
  import {GemJoin} from 'dss/join.sol';
  import {End}  from './end.sol';

  contract Hevm {
      function warp(uint256) public;
  }

  contract PipLike {
      function read() public returns (bytes32);
      function poke(bytes32 val) public;
  }

  contract TestSpot {
      struct Ilk {
          address pip;
          uint256 mat;
      }
      mapping (bytes32 => Ilk) public ilks;

      function file(bytes32 ilk, address pip_) public {
          ilks[ilk].pip = pip_;
      }
  }

  <<test-usr>>

  contract EndTest is DSTest {
      Hevm hevm;

      Vat   vat;
      End   end;
      Vow   vow;
      Cat   cat;

      DSToken gold;

      PipLike pip;
      TestSpot spot;

      GemJoin gemA;

      Flipper flip;
      Flapper flap;
      Flopper flop;

      <<test-helper>>

      <<test-setUp>>

      <<test-cage-basic>>

      // -- Scenario where there is one well-collateralised CDP
      // -- and there is no Vow deficit or surplus
      <<test-cage-collateralised>>

      // -- Scenario where there is one well-collateralised and one
      // -- under-collateralised CDP, and no Vow deficit or surplus
      <<test-cage-undercollateralised>>

      // -- Scenario where there is one collateralised CDP
      // -- undergoing auction at the time of cage
      <<test-cage-skip>>

      // -- Scenario where there is one well-collateralised CDP
      // -- and there is a deficit in the Vow
      <<test-cage-collateralised-deficit>>

      // -- Scenario where there is one well-collateralised CDP
      // -- and one under-collateralised CDP and there is a
      // -- surplus in the Vow
      <<test-cage-undercollateralised-surplus>>
  }
#+END_SRC

** Setup

A helper contract that represents a user:

#+NAME: test-usr
#+BEGIN_SRC sol
  contract Usr {
      Vat public vat;
      End public end;
      GemJoin public gemA;

      constructor(Vat vat_, End end_, GemJoin gemA_) public {
          vat  = vat_;
          end  = end_;
          gemA = gemA_;
      }
      function frob(bytes32 ilk, address u, address v, address w, int dink, int dart) public {
          vat.frob(ilk, u, v, w, dink, dart);
      }
      function flux(bytes32 ilk, address src, address dst, uint256 wad) public {
          vat.flux(ilk, src, dst, wad);
      }
      function move(address src, address dst, uint256 rad) public {
          vat.move(src, dst, rad);
      }
      function hope(address usr) public {
          vat.hope(usr);
      }
      function join(address urn, uint wad) public {
          gemA.join(urn, wad);
      }
      function exit(address usr, uint wad) public {
          gemA.exit(usr, wad);
      }
      function free(bytes32 ilk) public {
          end.free(ilk);
      }
      function shop(uint256 rad) public {
          end.shop(rad);
      }
      function pack(bytes32 ilk) public {
          end.pack(ilk);
      }
      function cash(bytes32 ilk) public {
          end.cash(ilk);
      }
  }
#+END_SRC

Some helper functions for the test contract:

#+NAME: test-helper
#+BEGIN_SRC sol
    uint constant WAD = 10 ** 18;
    uint constant RAY = 10 ** 27;

    function ray(uint wad) internal pure returns (uint) {
        return wad * 10 ** 9;
    }
    function rad(uint wad) internal pure returns (uint) {
        return wad * RAY;
    }
    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = x * y;
        require(y == 0 || z / y == x);
        z = z / RAY;
    }
    function min(uint x, uint y) internal pure returns (uint z) {
        (x >= y) ? z = y : z = x;
    }
    function dai(address urn) internal view returns (uint) {
        return vat.dai(urn) / RAY;
    }
    function gem(bytes32 ilk, address urn) internal view returns (uint) {
        return vat.gem(ilk, urn);
    }
    function ink(bytes32 ilk, address urn) internal view returns (uint) {
        (uint ink_, uint art_) = vat.urns(ilk, urn); art_;
        return ink_;
    }
    function art(bytes32 ilk, address urn) internal view returns (uint) {
        (uint ink_, uint art_) = vat.urns(ilk, urn); ink_;
        return art_;
    }
#+END_SRC

We deploy the necessary components of the system for testing:

#+NAME: test-setUp
#+BEGIN_SRC sol
  function setUp() public {
      hevm = Hevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
      hevm.warp(0);

      vat = new Vat();
      DSToken gov = new DSToken('GOV');

      flap = new Flapper(address(vat), address(gov));
      flop = new Flopper(address(vat), address(gov));
      gov.setOwner(address(flop));

      vow = new Vow(address(vat), address(flap), address(flop));

      cat = new Cat(address(vat));
      cat.file("vow", address(vow));
      vat.rely(address(cat));
      vow.rely(address(cat));

      gold = new DSToken("GEM");
      gold.mint(20 ether);

      pip = PipLike(address(new DSValue()));
      spot = new TestSpot();
      spot.file("gold", address(pip));
      // initial collateral price of 5
      pip.poke(bytes32(5 * RAY));

      vat.init("gold");
      gemA = new GemJoin(address(vat), "gold", address(gold));

      // 1 gold = 6 dai and liquidation ratio is 200%
      vat.file("gold", "spot",    ray(3 ether));
      vat.file("gold", "line", rad(1000 ether));
      vat.file("Line",         rad(1000 ether));

      gold.approve(address(gemA));
      gold.approve(address(vat));

      vat.rely(address(gemA));

      flip = new Flipper(address(vat), "gold");
      cat.file("gold", "flip", address(flip));
      cat.file("gold", "chop", ray(1 ether));
      cat.file("gold", "lump", rad(15 ether));
      vat.hope(address(flip));

      end = new End();
      end.file("vat", address(vat));
      end.file("cat", address(cat));
      end.file("vow", address(vow));
      end.file("spot", address(spot));
      end.file("wait", 1 hours);
      vat.rely(address(end));
      vow.rely(address(end));
      cat.rely(address(end));
      flip.rely(address(end));
      flap.rely(address(vow));
      flop.rely(address(vow));
  }

#+END_SRC

The first basic test ensures that =end.cage(hump)= is able to run and sets the liveness flags correctly:

#+NAME: test-cage-basic
#+BEGIN_SRC sol
  function test_cage_basic() public {
      assertEq(end.live(), 1);
      assertEq(vat.live(), 1);
      assertEq(cat.live(), 1);
      assertEq(vow.live(), 1);
      assertEq(vow.flopper().live(), 1);
      assertEq(vow.flapper().live(), 1);
      end.cage();
      assertEq(end.live(), 0);
      assertEq(vat.live(), 0);
      assertEq(cat.live(), 0);
      assertEq(vow.live(), 0);
      assertEq(vow.flopper().live(), 0);
      assertEq(vow.flapper().live(), 0);
  }
#+END_SRC

** Testing the case with no undercollateralised CDPs

The next test simulates a basic =cage= scenario with one CDP which is not undercollateralised. We follow the computations for \( {\tt tag } \) and \( {\tt fix } \) that were proposed earlier. With only one collateral type and no system debt, they simplify to:

\[
{\tt tag} = {\tt fix} = \frac{1}{p_i}
\]

We assume that the price of ="gold"= is now 5 dai, so \( {\tt tag} \) and \( {\tt fix} \) will both be \( \frac{1}{5} \).

#+NAME: test-cage-collateralised
#+BEGIN_SRC sol
  function test_cage_collateralised() public {
      Usr ali = new Usr(vat, end, gemA);

      // make a CDP:
      address urn1 = address(ali);
      gemA.join(urn1, 10 ether);
      ali.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // ali's urn has 0 gem, 10 ink, 15 tab, 15 dai

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), 0);

      // collateral price is 5
      pip.poke(bytes32(5 * RAY));
      end.cage();
      end.cage("gold");
      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(address(vow)), rad(15 ether));

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), rad(15 ether));

      // CDP closing
      ali.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      ali.exit(address(this), 7 ether);

      hevm.warp(1 hours);
      end.thaw();
      end.flow("gold");
      assertTrue(end.fixs("gold") != 0);

      // dai redemption
      ali.hope(address(end));
      ali.shop(15 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      ali.pack("gold");
      ali.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      ali.exit(address(this), 3 ether);

      assertEq(gem("gold", address(end)), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }

#+END_SRC

** Testing the case with CDP parity

We test the case where there are two CDPs, one of the CDP is undercollateralised, and we ensure CDP parity (at the expense of dai parity). Suppose the price of ="gold"= falls as low as 2 dai, then \( {\tt tag} \) is \( \frac{1}{2} \) while \( {\tt fix} \) is given by equation \ref{eq:fixcdpparity}:

\[
{\tt fix} = \frac{17}{36} = 0.472 \ldots
\]

#+NAME: test-cage-undercollateralised
#+BEGIN_SRC sol
  function test_cage_undercollateralised() public {
      Usr ali = new Usr(vat, end, gemA);
      Usr bob = new Usr(vat, end, gemA);

      // make a CDP:
      address urn1 = address(ali);
      gemA.join(urn1, 10 ether);
      ali.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // ali's urn has 0 gem, 10 ink, 15 tab, 15 dai

      // make a second CDP:
      address urn2 = address(bob);
      gemA.join(urn2, 1 ether);
      bob.frob("gold", urn2, urn2, urn2, 1 ether, 3 ether);
      // bob's urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // collateral price is 2
      pip.poke(bytes32(2 * RAY));
      end.cage();
      end.cage("gold");
      end.skim("gold", urn1);
      // undercollateralised CDP is bailed
      end.bail("gold", urn2);

      // local checks
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 2.5 ether);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(address(vow)), rad(18 ether));

      // global checks
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      ali.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 2.5 ether);
      ali.exit(address(this), 2.5 ether);

      hevm.warp(1 hours);
      end.thaw();
      end.flow("gold");
      assertTrue(end.fixs("gold") != 0);

      // first dai redemption
      ali.hope(address(end));
      ali.shop(15 ether);

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      ali.pack("gold");
      ali.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      uint256 fix = end.fixs("gold");
      assertEq(gem("gold", urn1), rmul(fix, 15 ether));
      ali.exit(address(this), rmul(fix, 15 ether));

      // second dai redemption
      bob.hope(address(end));
      bob.shop(3 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      bob.pack("gold");
      bob.cash("gold");

      // local checks:
      assertEq(dai(urn2), 0);
      assertEq(gem("gold", urn2), rmul(fix, 3 ether));
      bob.exit(address(this), rmul(fix, 3 ether));

      // some dust remains in the End because of rounding:
      assertEq(gem("gold", address(end)), 1);
      assertEq(gold.balanceOf(address(gemA)), 1);
  }

#+END_SRC

** Testing =skip=

We now test the case when there are two CDPs, one of which is undercollateralised, but such that the =Ilk= as a whole is well collateralised.

#+NAME: test-cage-skip
#+BEGIN_SRC sol
  function test_cage_skip() public {
      Usr ali = new Usr(vat, end, gemA);

      // make a CDP:
      address urn1 = address(ali);
      gemA.join(urn1, 10 ether);
      ali.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      vat.file("gold", "spot", ray(1 ether));     // now unsafe

      uint id = cat.bite("gold", urn1);           // CDP liquidated
      assertEq(vat.vice(), rad(15 ether));        // now there is sin
      uint auction = cat.flip(id, rad(15 ether)); // flip all the tab
      // get 1 dai from ali
      ali.move(address(ali), address(this), rad(1 ether));
      vat.hope(address(flip));
      flip.tend(auction, 10 ether, rad(1 ether)); // bid 1 dai
      assertEq(dai(urn1), 14 ether);

      // collateral price is 5
      pip.poke(bytes32(5 * RAY));
      end.cage();
      end.cage("gold");

      end.skip("gold", auction);
      assertEq(dai(address(this)), 1 ether);       // bid refunded
      vat.move(address(this), urn1, rad(1 ether)); // return 1 dai to ali

      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(address(vow)), rad(30 ether));

      // balance the vow
      vow.flog(uint48(now));
      vow.heal(min(vow.Joy(), vow.Woe()));
      vow.kiss(min(vow.Joy(), vow.Ash()));
      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), rad(15 ether));

      // CDP closing
      ali.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      ali.exit(address(this), 7 ether);

      hevm.warp(1 hours);
      end.thaw();
      end.flow("gold");
      assertTrue(end.fixs("gold") != 0);

      // dai redemption
      ali.hope(address(end));
      ali.shop(15 ether);

      // global checks:
      // no need for vent
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      ali.pack("gold");
      ali.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      ali.exit(address(this), 3 ether);

      assertEq(gem("gold", address(end)), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

** Testing surplus and deficit

#+NAME: test-cage-collateralised-deficit
#+BEGIN_SRC sol
  function test_cage_collateralised_deficit() public {
      Usr ali = new Usr(vat, end, gemA);

      // make a CDP:
      address urn1 = address(ali);
      gemA.join(urn1, 10 ether);
      ali.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // ali's urn has 0 gem, 10 ink, 15 tab, 15 dai
      // suck 1 dai and give to ali
      vat.suck(address(vow), address(ali), rad(1 ether));

      // global checks:
      assertEq(vat.debt(), rad(16 ether));
      assertEq(vat.vice(), rad(1 ether));

      // collateral price is 5
      pip.poke(bytes32(5 * RAY));
      end.cage();
      end.cage("gold");
      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(address(vow)), rad(16 ether));

      // global checks:
      assertEq(vat.debt(), rad(16 ether));
      assertEq(vat.vice(), rad(16 ether));

      // CDP closing
      ali.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      ali.exit(address(this), 7 ether);

      hevm.warp(1 hours);
      end.thaw();
      end.flow("gold");
      assertTrue(end.fixs("gold") != 0);

      // dai redemption
      ali.hope(address(end));
      ali.shop(16 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      ali.pack("gold");
      ali.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      ali.exit(address(this), 3 ether);

      assertEq(gem("gold", address(end)), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

#+NAME: test-cage-undercollateralised-surplus
#+BEGIN_SRC sol
  function test_cage_undercollateralised_surplus() public {
      Usr ali = new Usr(vat, end, gemA);
      Usr bob = new Usr(vat, end, gemA);

      // make a CDP:
      address urn1 = address(ali);
      gemA.join(urn1, 10 ether);
      ali.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // ali's urn has 0 gem, 10 ink, 15 tab, 15 dai
      // alive gives one dai to the vow, creating surplus
      ali.move(address(ali), address(vow), rad(1 ether));

      // make a second CDP:
      address urn2 = address(bob);
      gemA.join(urn2, 1 ether);
      bob.frob("gold", urn2, urn2, urn2, 1 ether, 3 ether);
      // bob's urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // collateral price is 2
      pip.poke(bytes32(2 * RAY));
      end.cage();
      end.cage("gold");
      end.skim("gold", urn1);
      // undercollateralised CDP is bailed
      end.bail("gold", urn2);

      // local checks
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 2.5 ether);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(address(vow)), rad(18 ether));

      // global checks
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      ali.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 2.5 ether);
      ali.exit(address(this), 2.5 ether);

      hevm.warp(1 hours);
      // vent to absorb the surplus
      vow.heal(rad(1 ether));
      end.thaw();
      end.flow("gold");
      assertTrue(end.fixs("gold") != 0);

      // first dai redemption
      ali.hope(address(end));
      ali.shop(14 ether);

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      ali.pack("gold");
      ali.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      uint256 fix = end.fixs("gold");
      assertEq(gem("gold", urn1), rmul(fix, 14 ether));
      ali.exit(address(this), rmul(fix, 14 ether));

      // second dai redemption
      bob.hope(address(end));
      bob.shop(3 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      bob.pack("gold");
      bob.cash("gold");

      // local checks:
      assertEq(dai(urn2), 0);
      assertEq(gem("gold", urn2), rmul(fix, 3 ether));
      bob.exit(address(this), rmul(fix, 3 ether));

      // nothing left in the End
      assertEq(gem("gold", address(end)), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

* Further Work

** NFT Settlement Modules (TODO)

NFTs need to be dealt with separately, by assigning ownership of the tokens and their associated debt to a special settlement module.
