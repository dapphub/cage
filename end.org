#+TITLE: `cage`
#+DATE: <2019-01-24 Thu>
#+AUTHOR:
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+OPTIONS: html-postamble:nil tex:mathjax
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+PROPERTY: header-args :results output :exports both :noweb strip-export :tangle no :mkdirp yes
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./body.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./theme.css"/>
#+HTML_HEAD_EXTRA: <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="/home/lev/src/MathJax/MathJax.js?config=TeX-AMS_HTML-full"><\/script>')</script>

#+OPTIONS:
# Local Variables:
# org-confirm-babel-evaluate: nil
# org-babel-exp-code-template: "#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC"
# End:

#+NAME: solidity-skeleton
#+BEGIN_SRC sol :tangle "src/end.sol" :exports none
  /// end.sol -- global settlement engine

  // <<license>>

  pragma solidity >=0.5.0;
  pragma experimental ABIEncoderV2;

  contract VatLike {
      struct Ilk {
          uint256 rate;
          uint256 Art;
          uint256 spot;
          uint256 line;
          uint256 dust;
      }
      struct Urn {
          uint256 ink;
          uint256 art;
      }
      function sin(bytes32) public view returns (uint);
      function dai(bytes32 lad) public returns (uint256);
      function ilks(bytes32 ilk) public returns (Ilk memory);
      function urns(bytes32 ilk, bytes32 urn) public returns (Urn memory);
      function move(bytes32 src, bytes32 dst, int256 rad) public;
      function flux(bytes32 ilk, bytes32 src, bytes32 dst, int256 rad) public;
      function tune(bytes32 i, bytes32 u, bytes32 v, bytes32 w, int256 dink, int256 dart) public;
      function grab(bytes32 i, bytes32 u, bytes32 v, bytes32 w, int256 dink, int256 dart) public;
      function heal(bytes32 u, bytes32 v, int256 rad) public;
      function cage() public;
  }
  contract CatLike {
      struct Ilk {
          address flip;  // Liquidator
          uint256 chop;  // Liquidation Penalty   [ray]
          uint256 lump;  // Liquidation Quantity  [wad]
      }
      function ilks(bytes32) public returns (Ilk memory);
      function cage() public;
  }
  contract VowLike {
      function Joy() public returns (uint256);
      function Woe() public returns (uint256);
      function hump() public returns (uint256);
      function heal(uint256 wad) public;
  }
  contract Flippy {
      struct Bid {
          uint256 bid;
          uint256 lot;
          address guy;
          uint48  tic;
          uint48  end;
          bytes32 urn;
          address gal;
          uint256 tab;
      }
      function cage() public;
      function bids(uint id) public view returns (Bid memory);
      function yank(uint id) public;
  }

  contract End {

      // --- Auth ---
      <<auth>>

      // --- Data ---
      <<data>>

      // --- Init ---
      <<init>>

      // --- Helpers ---
      <<helper>>

      // --- Math ---
      <<math>>

      // --- Administration ---
      <<file>>

      // --- Settlement ---
      <<cage>>

      <<cage-ilk>>

      <<skip>>

      <<skim>>

      <<free>>

      <<shop>>

      <<pack>>

      <<cash>>

      <<vent>>
  }
#+END_SRC

#+NAME: act-skeleton
#+BEGIN_SRC act :tangle "act/end.act" :exports none
   // <<license>>

   <<act-file>>

   <<act-cage>>

   <<act-cage-ilk>>

   <<act-skip>>

   <<act-skim>>

   <<act-free>>

   <<act-shop>>

   <<act-pack>>

   <<act-cash>>

   <<act-vent>>
#+END_SRC

* License
#+NAME: license
#+BEGIN_SRC fundamental
  Copyright (C) 2018 Rain <rainbreak@riseup.net>
  Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC


* Introduction
=`cage`= is the most complex mechanism in =dss=. This is because it must alter the behaviour of almost every component of the system and it must perform under a variety of possible (under)collateralisation regimes. In particular, there are a number of key properties, such as dai and CDP parity, or the lack of race conditions, which should be guaranteed even in edge cases, e.g. in the presence of CDPs which have become less than 100% collateralised. This means that a relatively complex calculation must be performed to determine the correct rates for collateral redemption by dai and CDP owners: this calculation is likely done off-chain and relies on up-to-date price data. Since in some edge cases it will not be possible to satisfy all desirable properties at once, a choice must be made about which to prioritise.

The procedure for =cage= looks roughly as follows:
1. The top-level =cage= method is called, which puts all system components into post-=cage= mode.
2. If necessary, the surplus buffer of dai (or a fraction thereof) in the =Vow= is burned.
3. For each collateral type, dai and CDP collateral redemption rates are calculated and fed into the system via the per-=Ilk= =cage= methods. In the simplest case they are just the price of each collateral type, however if the system is in a regime where there are undercollateralised CDPs, then adjustments must be made, requiring an off-chain calculation. A choice can be made between /CDP parity/ or /dai parity/.
4. Any ongoing collateral auctions that have not yet raised the dai to cover their debt are blocked from finalising, and are reversed with =skip=, returning the collateral and debt to the original CDP.
5. CDP owners can now redeem the collateral from their settled positions with =skim=.
6. dai holders can redeem the collateral they are entitled to by going through =shop=, =pack=, and =cash=.

* Setup
We will require safe addition, subtraction, and multiplication, =ray= fixed-point multiplication, safe =int= casting, and =min=:
#+NAME: math
#+BEGIN_SRC sol
  function add(uint x, uint y) internal pure returns (uint z) {
      z = x + y;
      require(z >= x);
  }
  function sub(uint x, uint y) internal pure returns (int z) {
      z = int(x - y);
      require(x < y || z >= 0);
      require(x > y || z <= 0);
  }
  function mul(uint x, uint y) internal pure returns (uint z) {
      z = x * y;
      require(y == 0 || z / y == x);
  }

  uint constant RAY = 10 ** 27;
  function rmul(uint x, uint y) internal pure returns (uint z) {
      z = x * y;
      require(y == 0 || z / y == x);
      z = z / RAY;
  }
  function u2i(uint x) internal pure returns (int y) {
      y = int(x);
      require(y >= 0);
  }
  function min(uint x, uint y) internal pure returns (uint z) {
      if (x > y) { z = y; } else { z = x; }
  }
  function min(int x, int y) internal pure returns (int z) {
      if (x > y) { z = y; } else { z = x; }
  }
#+END_SRC

We define a function for casting an =address= to a =bytes32=:
#+NAME: helper
#+BEGIN_SRC sol
  function b32(address a) internal pure returns (bytes32 b) {
      b = bytes32(bytes20(a));
  }
#+END_SRC

The contract that coordinates =cage= is called the =End=. The storage layout of the =End= is as follows:
#+NAME: data
#+BEGIN_SRC sol
  VatLike  public vat;
  CatLike  public cat;
  VowLike  public vow;
  uint256  public live;

  mapping (address => uint256)                      public dai;
  mapping (bytes32 => uint256)                      public tags;
  mapping (bytes32 => uint256)                      public fixs;
  mapping (bytes32 => mapping (bytes32 => uint256)) public bags;
#+END_SRC

The =End= uses the same multiowner auth model as the other =dss= contracts:

#+NAME: auth
#+BEGIN_SRC sol
  mapping (address => uint) public wards;
  function rely(address guy) public auth { wards[guy] = 1; }
  function deny(address guy) public auth { wards[guy] = 0; }
  modifier auth { require(wards[msg.sender] == 1); _; }
#+END_SRC

The constructor simply sets the creating account as owner and marks the system as =live=, i.e. uncaged:
#+NAME: init
#+BEGIN_SRC sol
  constructor() public {
      wards[msg.sender] = 1;
      live = 1;
  }
#+END_SRC

The target contracts of the =End= can be modified by owners in-flight:

#+NAME: file
#+BEGIN_SRC sol
  function file(bytes32 what, address data) public auth {
      if (what == "vat") vat = VatLike(data);
      if (what == "cat") cat = CatLike(data);
      if (what == "vow") vow = VowLike(data);
  }
#+END_SRC

#+NAME: act-file
#+BEGIN_SRC act
  behaviour file of End
  interface file(bytes32 what, address data)

  types

      Vat_was  : address
      Cat_was  : address
      Vow_was  : address

  storage

      wards[CALLER_ID] |-> Can
      Vat  |-> Vat_was => #if what == #string2Word("vat")  #then data else Vat_was
      Cat  |-> Cat_was => #if what == #string2Word("cat")  #then data else Cat_was
      Vow  |-> Vow_was => #if what == #string2Word("vow")  #then data else Vow_was

  iff

      Can == 1
#+END_SRC

* The =cage= process
First, the top-level =cage= method is called, which sets the =live= flag to zero and initiates =cage= in the other relevant system modules:

#+NAME: cage
#+BEGIN_SRC sol
  function cage(uint256 dump) public auth {
      require(live == 1);
      vat.cage();
      cat.cage();
      vow.heal(min(vow.Joy(), vow.Woe()));
      vat.move(b32(address(vow)), b32(address(this)), u2i(min(mul(vow.Joy(), RAY), mul(vow.hump(), dump))));
      live = 0;
  }
#+END_SRC

#+NAME: act-cage
#+BEGIN_SRC act
  behaviour cage of End
  interface cage(uint256 dump)

  types

      Can         : uint256
      Vat         : address
      Cat         : address
      Vow         : address
      Can_vat     : uint256
      Can_cat     : uint256
      Can_vow     : uint256
      Live        : uint256
      Vat_live    : uint256
      Cat_live    : uint256
      Vow_live    : uint256
      Ssin        : uint256
      Ash         : uint256
      Dai         : uint256
      Sin         : uint256
      Vice        : uint256
      Debt        : uint256
      Dai_end     : uint256
      Can_vat_vow : uint256

  storage

      wards[CALLER_ID] |-> Can
      cat              |-> Cat
      vow              |-> Vow
      live             |-> Live => 0

  storage Cat

      wards[ACCT_ID]   |-> Can_cat
      live             |-> Cat_live => 0

  storage Vow

      wards[ACCT_ID]   |-> Can_vow
      live             |-> Vow_live => 0
      Sin              |-> Ssin
      Ash              |-> Ash
      Hump             |-> Hump

  storage Vat

      wards[ACCT_ID] |-> Can_vat
      wards[Vow]     |-> Can_vat_vow
      live           |-> Vat_live => 0
      dai[Vow]       |-> Dai      => Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray \
                                          - #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)
      sin[Vow]       |-> Sin      => Sin  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      vice           |-> Vice     => Vice - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      debt           |-> Debt     => Debt - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      dai[ACCT_ID]   |-> Dai_end  => Dai_end \
                                          + #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)

  iff in range uint256

      Sin / #Ray - Ssin
      (Sin / #Ray - Ssin) - Ash
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Sin  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Vice - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Debt - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray
      Hump * dump
      Dai_end + #min(Hump * dump, Dai  - #min(Dai / #Ray, (Sin / #Ray - Ssin) - Ash) * #Ray)

  iff

      Live        == 1
      Can         == 1
      Can_vat     == 1
      Can_cat     == 1
      Can_vow     == 1
      Can_vat_vow == 1
#+END_SRC

The /=hump= burn ratio/, here called =dump=, is a parameter that determines what fraction of the =Vow='s dai buffer is to be burned: =0= if none of it, and =WAD= if all of it.

Next, the per-=Ilk= =cage= method is called, supplying two rates, called =tag= and =fix=, once for each collateral type.

#+NAME: cage-ilk
#+BEGIN_SRC sol
  function cage(bytes32 ilk, uint256 tag, uint256 fix) public auth {
      require(live == 0);
      tags[ilk] = tag;
      fixs[ilk] = fix;
      Flippy(cat.ilks(ilk).flip).cage();
  }
#+END_SRC

#+NAME: act-cage-ilk
#+BEGIN_SRC act
  behaviour cage-ilk of End
  interface cage(bytes32 ilk, uint256 tag, uint256 fix)

  types

      Can  : uint256
      Live : uint256
      Cat  : address CatLike
      Flip : address Flippy

  storage

      wards[CALLER_ID] |-> Can
      live             |-> Live
      tags[ilk]        |-> _ => tag
      fixs[ilk]        |-> _ => fix

  storage Cat

      ilks[ilk].flip   |-> Flip

  storage Flip

      wards[CALLER_ID] |-> Can_flip
      live             |-> Flip_live => 0

  iff

      Can      == 1
      Live     == 0
      Can_flip == 1
#+END_SRC

At this point, any outstanding `Flip` auctions that have not yet raised their target amount of dai can be cancelled ("yanked") by calling the public method =skip(uint id)=. When an auction is yanked, the collateral and debt are assigned back to the original CDP, which will then be settled as if it had not yet been liquidated, and the highest bidder is refunded their dai. Auctions that have already raised their target amount of dai are allowed to proceed as normal and can receive further =dent= bids.

#+NAME: skip
#+BEGIN_SRC sol
  function skip(bytes32 ilk, uint256 id) public {
      require(live == 0);

      address flip = cat.ilks(ilk).flip;
      Flippy.Bid memory bid = Flippy(flip).bids(id);

      VatLike.Ilk memory i = vat.ilks(ilk);
      uint256 dink = rmul(bid.lot, RAY);
      uint256 dart = mul(bid.tab, RAY) / i.rate;

      Flippy(flip).yank(id);

      vat.heal(b32(address(vow)), b32(address(vow)), min(0, sub(vat.sin(b32(address(vow))), mul(i.rate, dart))));
      vat.grab(ilk, bid.urn, b32(address(this)), b32(address(vow)), int(dink), int(dart));
  }
#+END_SRC

#+NAME: act-skip
#+BEGIN_SRC act
  // TODO
#+END_SRC

For the purposes of the upcoming calculation, we will assume that all
yankable auctions have been yanked. In particular by the /adjusted dai supply/, denoted by \( {\tt debt}^\prime \), we will mean the predicted value of the total dai supply once all outstanding auctions have finalised, which requires no further assumptions since all auctions remaining at this point have raised their target amounts of dai. In other words, we can assume without any loss of generality that no collateral auctions will finish in deficit.

** Interlude: the =fix= computation

The =fix= represents the quantity of =gem= that a user will be able to redeem for one dai. We now describe the procedure by which it should be computed, presumably by an off-chain agent. In the following calculation, for notational simplicity, the appropriate operations for fixed point units are implicit, e.g. \( {\tt hump} \cdot {\tt dump} \) is the number of dai from the =hump= that will be burned, \( {\tt art_{iu}} \cdot {\tt rate_i} \) is the outstanding dai debt of CDP =u=, etc.

In this case, the total quantity of dai that must be redeemable through =End= is the adjusted dai supply \( {\tt debt}^\prime \) minus the amount from the =hump= that was burned during =Vow.cage(dump)=, i.e.:

\[
{\tt debt}^\prime - {\tt hump \cdot dump}
\]

The first priority is to ensure that there is no race condition. That is to say, that with the \( {\tt fix_i}\) and \({\tt tag_i} \) that we chosen, every dai holder will be able to redeem the same quantity of =gem=, regardless of when they interact with the =End=, i.e.:

\[
\sum_u {\tt war_{iu}} = {\tt fix_i} \cdot ({\tt debt}^\prime - {\tt hump \cdot dump })
\]

We shall call this the /no-race property/. Setting \( {\tt war_{iu}} \) to be \( \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i }) \), where \( {\tt tag_i} \) is some /CDP settlement rate/, to be determined, we can solve for \( {\tt fix_i } \):

\[
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\]

Another desirable feature is for all =gem= redeemable for one dai to be worth one dollar:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1
\]

We call this the /dai parity property/. Similarly, it is desirable for CDPs to be settled at the market value of their collateral, i.e. that:

\[
{\tt tag_i } = \frac{1}{p_i}
\]

We call this the /CDP parity property/.

**** In the absence of undercollateralised positions

Consider the case where no CDPs are undercollateralised, i.e. that for all =u=, \( {\tt art_{iu}} \cdot {\tt rate_i} \geq {\tt ink_{iu}} \cdot p_{{\tt i}} \). Then we can satisfy all three constraints simultaneously simply by setting \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \):

\[
{\tt fix_i} = \frac{{\tt rate_i} \cdot {\tt tag_i } \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt rate_i} \cdot {\tt Art_i}}{p_{{\tt i}}\cdot({\tt debt}^\prime - {\tt hump \cdot dump })}
\]

Writing \( {\tt pump} := \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump}\cdot{\tt dump}} \) for the /=hump= burn multiplier/:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = \frac{\sum_i {\tt rate_i} \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump \cdot dump }} = {\tt pump}
\]

from which it is clear that we could use \( {\tt dump } = 0 \) and satisfy the no-race property and both parity properties.

**** In the presence of undercollateralised positions

***** Ensuring CDP parity:

Now if some CDPs had been undercollateralised, we would have had instead:

\begin{equation}
\label{eq:fixcdpparity}
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, \frac{{\tt art_{iu}} \cdot {\tt rate_i}}{p_{{\tt i}}})}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i}}{p_{{\tt i}}({\tt debt}^\prime - {\tt hump \cdot dump })}
\end{equation}

and the value redeemable from one dai would be:

\begin{align*}
\sum_i {\tt fix_i} \cdot p_{{\tt i}} & = \frac{\sum_i {\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i} }{{\tt debt}^\prime - {\tt hump \cdot dump }} \\
                                     & = \frac{{\tt debt} - {\tt Gap}}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\end{align*}

where \( {\tt gap_i} := \sum_u \mathrm{max} (0, {\tt art_{iu}} \cdot {\tt rate_i} - p_{{\tt i}} \cdot {\tt ink_i}) \) and \( {\tt Gap} := \sum_i {\tt gap_i} \), are the per =Ilk= and global gross negative CDP equity, respectively. Thus, though we have ensured the no-race and CDP parity properties, we have not necessarily ensured dai parity. However, if =hump= is large enough relative to =Gap=, it may be possible to ensure that the above expression equals one, solely by increasing =dump=.

***** Ensuring dai parity:

We might also be able to set \( {\tt tag_i } \) and \( {\tt fix_i } \) so as to guarantee dai parity. We could start by postulating that for all \( {\tt i} \):

\begin{equation}
\label{eq:fixdaiparity}
{\tt fix_i} \cdot p_{{\tt i}} = \frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt}^\prime}
\end{equation}

which will ensure that \( \sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1 \) due to the fundamental equation of dai.

It remains to choose the \( {\tt tag_i} \) such that losses from undercollateralised CDPs of =Ilk= =i= are socialised across all CDPs of the =Ilk=. This means that we will only be able to guarantee parity in the case that each =Ilk= is on aggregate not undercollateralised.

When socialising proportionally to debt, e have to solve the following for \( {\tt tag_i} \):

\begin{equation}
\label{eq:tagdaiparity-debt}
\frac{{\tt Art_i} \cdot {\tt rate_i}}{{\tt debt}^\prime} = p_{{\tt i}} \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\end{equation}

This is a linear optimisation problem without a closed-form solution, which can be solved numerically by linear complementarity methods. It is easy to see that a solution exists precisely when

\[
{\tt Art_i} \cdot {\tt rate_i} \leq {\tt Ink_i} \cdot p_{\tt i} \cdot {\tt pump}
\]

i.e. the =Ilk= as a whole is not undercollateralised (after adjusting for the =dump=). Note also that when there are no undercollateralised CDPs in the =Ilk= =i= and with \( {\tt dump = 0} \), equation \ref{eq:tagdaiparity-debt} can be solved with \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \), so this generalises our previous solution. Note that there is again a choice of how much of the =hump= to burn, where if more of the =hump= is burned then a smaller loss is imposed on CDP holders.

**** Summary of parity conditions
To summarise, when there are undercollateralised CDPs, the options are:
***** Ensure CDP parity:
set \( {\tt tag_i} = \frac{1}{p_i} \) and \( {\tt fix_i} \) according to formula \ref{eq:fixcdpparity}. It may still be possible to also ensure dai parity with =dump= if the =hump= is large enough.
***** Ensure DAI parity:
in both cases, set =dump = 1= and \( {\tt fix_i} \) according to formula \ref{eq:fixdaiparity}.
****** by socialising proportionally to debt
Set \( {\tt tag_i} \) according to formula \ref{eq:tagdaiparity-debt}.

There are two additional redistribution methods that are not considered here:
****** by socialising proportionally to equity
****** by socialising proportionally to collateral

**** In the presence of an undercollateralised =Ilk=

A different calculation is necessary if there is an =Ilk= which is undercollateralised in aggregate, i.e. has \( {\tt Art_i} \cdot {\tt rate_i} \lt {\tt gap_i} \), and parity is desired. In that case, it is necessary to set the \( {\tt fix_i} \) in such a way as to socialise the losses from the undercollateralised =Ilk= across other collateral types. TODO: This calculation is TBA.

** CDP Settlement
Once =tag_i= has been provided, individual CDPs can be processed with =skim=, settling the position at the price implied by =tag_i=. This method is public, and both CDP holders and dai holders are incentivised to call it: the former in order to withdraw their remaining collateral, and the latter in order to make collateral available for redemption.
#+NAME: skim
#+BEGIN_SRC sol
  function skim(bytes32 ilk, bytes32 urn) public {
      require(tags[ilk] != 0);

      VatLike.Ilk memory i = vat.ilks(ilk);
      VatLike.Urn memory u = vat.urns(ilk, urn);

      uint war = min(u.ink, rmul(rmul(u.art, i.rate), tags[ilk]));

      vat.grab(ilk, urn, b32(address(this)), b32(address(this)), -int(war), -int(u.art));
  }
#+END_SRC

#+NAME: act-skim
#+BEGIN_SRC act
  behaviour skim of End
  interface skim(bytes32 ilk, bytes32 urn)

  types

      Tag    : uint256
      Vat    : address
      Can    : uint256
      Rate   : uint256
      Ink_u  : uint256
      Art_u  : uint256
      Ink    : uint256
      Art    : uint256
      Gem    : uint256
      Sin    : uint256
      Vice   : uint256

  storage

      tags[ilk] |-> Tag
      vat       |-> Vat

  storage Vat

      wards[ACCT_ID]     |-> Can
      ilks[ilk].rate     |-> Rate
      urns[ilk][urn].ink |-> Ink_u => Ink_u - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      urns[ilk][urn].art |-> Art_u => 0
      ilks[ilk].Ink      |-> Ink   => Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      ilks[ilk].Art      |-> Art   => Art - Art_u
      gem[ilk][ACCT_ID]  |-> Gem   => Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      sin[ACCT_ID]       |-> Sin   => Sin - Rate * Art_u
      vice               |-> Vice  => Vice - Rate * Art_u

  iff in range uint256

      Ink_u * #rmul(#rmul(Art_u, Rate), Tag)
      #rmul(Art_u, Rate) * Tag
      Art_u * Rate
      Ink - #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))
      Art - Art_u
      Gem + #min(Ink_u, #rmul(#rmul(Art_u, Rate), Tag))

  iff

      Can == 1
#+END_SRC

Since =frob= is now frozen, we also provide a method for CDP holder to remove their collateral from a settled =urn=, after =skim= has been called:

#+NAME: free
#+BEGIN_SRC sol
  function free(bytes32 ilk) public {
      // TODO: access to bytes
      VatLike.Urn memory u = vat.urns(ilk, b32(msg.sender));
      require(u.art == 0);
      vat.grab(ilk, b32(msg.sender), b32(msg.sender), b32(msg.sender), -int(u.ink), 0);
  }
#+END_SRC

#+NAME: act-free
#+BEGIN_SRC act
  behaviour free of End
  interface free(bytes32 ilk)

  types

      Vat : address
      Ink : uint256
      Art : uint256
      Gem : uint256

  storage

      vat |-> Vat

  storage Vat

      wards[ACCT_ID]           |-> Can
      urns[ilk][CALLER_ID].ink |-> Ink => 0
      urns[ilk][CALLER_ID].art |-> Art
      gem[ilk][CALLER_ID]      |-> Gem => Gem + Ink

  iff in range uint256

      Gem + Ink

  iff

      Can == 1
      Art == 0
#+END_SRC

** Redemption

A dai holder may exchange their =Vat= dai for =End= dai, which is a one-way process. At this point, the =sin= incurred by the =End= during =skim= is cancelled.

#+NAME: shop
#+BEGIN_SRC sol
  function shop(uint256 wad) public {
      vat.heal(b32(address(this)), b32(msg.sender), int(mul(wad, RAY)));
      dai[msg.sender] = add(dai[msg.sender], wad);
  }
#+END_SRC

#+NAME: act-shop
#+BEGIN_SRC act
  behaviour shop of End
  interface shop(uint256 wad)

  types

      Vat : address
      Sin : uint256

  storage

      vat            |-> Vat
      dai[CALLER_ID] |-> Dai => Dai + Wad

  storage Vat

      wards[ACCT_ID] |-> Can
      dai[CALLER_ID] |-> Rad  => 0
      sin[ACCT_ID]   |-> Sin  => Sin - wad * #Ray
      vice           |-> Vice => Vice - wad * #Ray
      debt           |-> Debt => Debt - wad * #Ray

  iff in range uint256

      Dai + wad * #Ray
      Sin - wad * #Ray

  iff

      Can == 1
#+END_SRC

For every =Ilk= that they wish to claim, the dai holder calls =pack=, receiving =bag= tokens (/backed asset guarantee tokens/) in the same quantity as the dai they are redeeming:

#+NAME: pack
#+BEGIN_SRC sol
  function pack(bytes32 ilk) public {
      require(bags[ilk][b32(msg.sender)] == 0);
      bags[ilk][b32(msg.sender)] = add(bags[ilk][b32(msg.sender)], dai[msg.sender]);
  }
#+END_SRC

#+NAME: act-pack
#+BEGIN_SRC act
  behaviour pack of End
  interface pack(bytes32 ilk)

  types

      Dai : uint256
      Nul : uint256

  storage

      dai[msg.sender]      |-> Dai
      bags[ilk][CALLER_ID] |-> Nul => Nul + Dai

  iff

      Nul == 0
#+END_SRC

Finally, they may withdraw every =gem= at a rate of \( {\tt fix_i} \) units for one dai, by calling =cash=.

#+NAME: cash
#+BEGIN_SRC sol
  function cash(bytes32 ilk) public {
      vat.flux(ilk, b32(address(this)), b32(msg.sender), int(rmul(bags[ilk][b32(msg.sender)], fixs[ilk])));
      bags[ilk][b32(msg.sender)]  = 0;
      dai[msg.sender]             = 0;
  }
#+END_SRC

#+NAME: act-cash
#+BEGIN_SRC act
  behaviour cash of End
  interface cash(bytes32 ilk)

  types

      Bag : uint256
      Dai : uint256

  storage

      vat                  |-> Vat
      bags[ilk][CALLER_ID] |-> Bag => 0
      dai[CALLER_ID]       |-> Dai => 0

  storage Vat

      wards[ACCT_ID]      |-> Can
      gem[ilk][ACCT_ID]   |-> Gem_end => Gem_end - #rmul(Bag, Fix)
      gem[ilk][CALLER_ID] |-> Gem_lad => Gem_lad + #rmul(Bag, Fix)

  iff in range uint256

      Bag * Fix
      Gem_end - #rmul(Bag, Fix)
      Gem_lad + #rmul(Bag, Fix)

  iff

      Can == 1
#+END_SRC

Irredeemable dai ends up in the =End= due to =dump=. =vent= is there to account for it:

#+NAME: vent
#+BEGIN_SRC sol
  function vent(uint256 rad) public {
      vat.heal(b32(address(this)), b32(address(this)), u2i(rad));
  }
#+END_SRC

#+NAME: act-vent
#+BEGIN_SRC act
  behaviour vent of End
  interface vent(uint256 rad)

  types

      Vat  : address VatLike
      Can  : uint256
      Dai  : uint256
      Sin  : uint256
      Debt : uint256
      Vice : uint256

  storage

      vat |-> Vat

  storage Vat

      Can[ACCT_ID] |-> Can
      dai[ACCT_ID] |-> Dai  => Dai  - rad
      sin[ACCT_ID] |-> Sin  => Sin  - rad
      debt         |-> Debt => Debt - rad
      vice         |-> Vice => Vice - rad

  iff

      Can == 1

  iff in range uint256

      Dai  - rad
      Sin  - rad
      Debt - rad
      Vice - rad
#+END_SRC

* Tests

#+NAME: solidity-test-skeleton
#+BEGIN_SRC sol :tangle "src/end.t.sol" :exports none
  // end.t.sol -- global settlement tests

  // <<license>>

  pragma solidity >=0.5.0;

  import "ds-test/test.sol";
  import "ds-token/token.sol";

  import {Vat}  from 'dss/vat.sol';
  import {Cat}  from 'dss/cat.sol';
  import {Vow}  from 'dss/vow.sol';
  import {Flipper} from 'dss/flip.sol';
  import {GemJoin} from 'dss/join.sol';
  import {GemMove, DaiMove} from 'dss/move.sol';
  import {End}  from './end.sol';

  contract EndTest is DSTest {
      Vat   vat;
      End   end;
      Vow   vow;
      Cat   cat;

      DSToken gold;

      GemJoin gemA;
      GemMove gemM;
      DaiMove daiM;

      Flipper flip;

      bytes32 urn1;
      bytes32 urn2;

      <<test-helper>>

      <<test-setUp>>

      <<test-cage-basic>>

      <<test-cage-collateralised>>

      <<test-cage-undercollateralised-cdp-parity>>

      // <<test-cage-undercollateralised-dai-parity-collateral>>

      <<test-cage-undercollateralised-dai-parity-debt>>

      <<test-cage-skip>>
  }
#+END_SRC

** Setup

Some helper functions for the test contract:

#+NAME: test-helper
#+BEGIN_SRC sol
  uint constant WAD = 10 ** 18;
  uint constant RAY = 10 ** 27;

  function ray(uint wad) internal pure returns (uint) {
      return wad * 10 ** 9;
  }
  function rad(uint wad) internal pure returns (uint) {
      return wad * RAY;
  }
  function rmul(uint x, uint y) internal pure returns (uint z) {
      z = x * y;
      require(y == 0 || z / y == x);
      z = z / RAY;
  }
  function dai(bytes32 urn) internal view returns (uint) {
      return vat.dai(urn) / RAY;
  }
  function gem(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      return vat.gem(ilk, urn);
  }
  function ink(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      (uint ink_, uint art_) = vat.urns(ilk, urn); art_;
      return ink_;
  }
  function art(bytes32 ilk, bytes32 urn) internal view returns (uint) {
      (uint ink_, uint art_) = vat.urns(ilk, urn); ink_;
      return art_;
  }
#+END_SRC

We deploy the necessary components of the system for testing:

#+NAME: test-setUp
#+BEGIN_SRC sol
  function setUp() public {
      vat = new Vat();

      vow = new Vow();
      vow.file("vat", address(vat));
      vat.rely(address(vow));

      cat = new Cat(address(vat));
      cat.file("vow", address(vow));
      vat.rely(address(cat));
      vow.rely(address(cat));

      gemM = new GemMove(address(vat), "gold");
      vat.rely(address(gemM));
      daiM = new DaiMove(address(vat));
      vat.rely(address(daiM));

      gold = new DSToken("GEM");
      gold.mint(20 ether);

      vat.init("gold");
      gemA = new GemJoin(address(vat), "gold", address(gold));

      // 1 gold = 6 dai and liquidation ratio is 200%
      vat.file("gold", "spot",    ray(3 ether));
      vat.file("gold", "line", rad(1000 ether));
      vat.file("Line",         rad(1000 ether));

      gold.approve(address(gemA));
      gold.approve(address(vat));

      vat.rely(address(gemA));

      flip = new Flipper(address(daiM), address(gemM));
      cat.file("gold", "flip", address(flip));
      cat.file("gold", "chop", ray(1 ether));
      cat.file("gold", "lump", uint(15 ether));
      vat.rely(address(flip));
      daiM.hope(address(flip));

      end = new End();
      end.file("vat", address(vat));
      end.file("cat", address(cat));
      end.file("vow", address(vow));
      vat.rely(address(end));
      cat.rely(address(end));
      flip.rely(address(end));
  }
#+END_SRC

The first basic test ensures that =end.cage(hump)= is able to run and sets the liveness flags correctly:

#+NAME: test-cage-basic
#+BEGIN_SRC sol
  function test_cage_basic() public {
      assert(end.live() == 1);
      assert(vat.live() == 1);
      assert(cat.live() == 1);
      end.cage(0);
      assert(end.live() == 0);
      assert(vat.live() == 0);
      assert(cat.live() == 0);
  }
#+END_SRC

** Testing the case with no undercollateralised CDPs

The next test simulates a basic =cage= scenario with one CDP which is not undercollateralised. We follow the computations for \( {\tt tag } \) and \( {\tt fix } \) that were proposed earlier. With only one collateral type and no system debt, they simplify to:

\[
{\tt tag} = {\tt fix} = \frac{1}{p_i}
\]

We assume that the price of ="gold"= is now 5 dai, so \( {\tt tag} \) and \( {\tt fix} \) will both be \( \frac{1}{5} \).

#+NAME: test-cage-collateralised
#+BEGIN_SRC sol
  function test_cage_collateralised() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      vat.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      uint tag = RAY / 5;
      uint fix = RAY / 5;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(15 ether));

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), rad(15 ether));

      // CDP closing
      end.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      gemA.exit(urn1, address(this), 7 ether);

      // dai redemption
      end.shop(15 ether);

      // global checks:
      // no need for vent
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      gemA.exit(urn1, address(this), 3 ether);

      assertEq(gem("gold", bytes32(bytes20(address(end)))), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

** Testing the case with CDP parity

We test the case where there are two CDPs, one of the CDP is undercollateralised, and we ensure CDP parity (at the expense of dai parity). Suppose the price of ="gold"= falls as low as 2 dai, then \( {\tt tag} \) is \( \frac{1}{2} \) while \( {\tt fix} \) is given by equation \ref{eq:fixcdpparity}:

\[
{\tt fix} = \frac{17}{36} = 0.472 \ldots
\]

#+NAME: test-cage-undercollateralised-cdp-parity
#+BEGIN_SRC sol
  function test_cage_undercollateralised_cdp_parity() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      vat.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // make a second CDP:
      urn2 = bytes32(uint256(bytes32(bytes20(address(this)))) + 1);
      gemA.join(urn2, 1 ether);
      vat.frob("gold", urn2, urn2, urn2, 1 ether, 3 ether);
      // this urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      // CDP holders settled at price of 2
      uint tag = RAY / 2;
      // DAI holders get ~0.944
      uint fix = (17 * RAY) / 36;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);
      end.skim("gold", urn2);

      // local checks
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 2.5 ether);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(18 ether));

      // global checks
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      end.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 2.5 ether);
      gemA.exit(urn1, address(this), 2.5 ether);

      // first dai redemption
      end.shop(15 ether);

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 15 ether));
      gemA.exit(urn1, address(this), rmul(fix, 15 ether));

      // gather remaining dai into urn1
      daiM.move(urn2, urn1, 3 ether);
      // second dai redemption
      end.shop(3 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 3 ether));
      gemA.exit(urn1, address(this), rmul(fix, 3 ether));

      // some dust remains in the End because of rounding:
      assertEq(gem("gold", bytes32(bytes20(address(end)))), 1);
      assertEq(gold.balanceOf(address(gemA)), 1);
  }
#+END_SRC

** Testing the case with dai parity

We now test the case when there are two CDPs, one of which is undercollateralised, but such that the =Ilk= as a whole is well collateralised.

*** socialising proportionally to debt

Here's a simple way we can compute the (exact) numerical solution using a bisection method:

#+BEGIN_SRC python :results output
  WAD = 10**18
  RAY = 10**27

  def rmul(x, y):
      return (x * y) // RAY

  def solve_by_bisection(f, toe, hat, tol=1, tries=1000):
      for _ in range(tries):
          cut = (toe + hat) // 2
          if f(cut) > tol:
              hat = cut
          elif f(cut) < -tol:
              toe = cut
          else:
              return cut

  Art  = 18 * WAD
  rate = RAY
  p    = 2

  inks = [10 * WAD, 1 * WAD]
  arts = [15 * WAD, 3 * WAD]

  f = lambda tag: p * sum([min(ink, rmul(rmul(art, rate), tag)) for ink, art in zip(inks, arts)]) - rmul(Art, rate)

  print(solve_by_bisection(f, 0, RAY))
#+END_SRC

#+RESULTS:
: 533333333333333333358631380

i.e. CDPs are settled at an implied price of \( 0.533\ldots^{-1} = 1.875 \), lower than the true price of \( 2.0 \).

#+NAME: test-cage-undercollateralised-dai-parity-debt
#+BEGIN_SRC sol
  function test_cage_undercollateralised_dai_parity_debt() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      vat.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      // make a second CDP:
      urn2 = bytes32(uint256(bytes32(bytes20(address(this)))) + 1);
      gemA.join(urn2, 1 ether);
      vat.frob("gold", urn2, urn2, urn2, 1 ether, 3 ether);
      // this urn has 0 gem, 1 ink, 3 tab, 3 dai

      // global checks:
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), 0);

      // tag and fix computation
      uint hump = 0;
      // CDP holders settled at price of 1.875
      uint tag = 533333333333333333358631380;
      // DAI holders get 1.0
      uint fix = RAY / 2;
      end.cage(hump);
      end.cage("gold", tag, fix);
      end.skim("gold", urn1);
      end.skim("gold", urn2);

      // local checks
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 2 ether);
      assertEq(art("gold", urn2), 0);
      assertEq(ink("gold", urn2), 0);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(18 ether));

      // global checks
      assertEq(vat.debt(), rad(18 ether));
      assertEq(vat.vice(), rad(18 ether));

      // CDP closing
      end.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 2 ether);
      gemA.exit(urn1, address(this), 2 ether);

      // first dai redemption
      end.shop(15 ether);

      // global checks:
      assertEq(vat.debt(), rad(3 ether));
      assertEq(vat.vice(), rad(3 ether));

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 15 ether));
      gemA.exit(urn1, address(this), rmul(fix, 15 ether));

      // gather remaining dai into urn1
      daiM.move(urn2, urn1, 3 ether);
      // second dai redemption
      end.shop(3 ether);

      // global checks:
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), rmul(fix, 3 ether));
      gemA.exit(urn1, address(this), rmul(fix, 3 ether));

      assertEq(gem("gold", bytes32(bytes20(address(end)))), 0);
      // some dust remains in the adapter because of rounding:
      assertTrue(gold.balanceOf(address(gemA)) < 2);
  }
#+END_SRC

** Testing auction yanking

#+NAME: test-cage-skip
#+BEGIN_SRC sol
  function test_cage_skip() public {
      // make a CDP:
      urn1 = bytes32(bytes20(address(this)));
      gemA.join(urn1, 10 ether);
      vat.frob("gold", urn1, urn1, urn1, 10 ether, 15 ether);
      // this urn has 0 gem, 10 ink, 15 tab, 15 dai

      vat.file("gold", "spot", ray(1 ether)); // now unsafe

      uint id = cat.bite("gold", urn1);       // CDP liquidated
      assertEq(vat.vice(), rad(15 ether));    // now there is sin
      uint auction = cat.flip(id, 15 ether);  // flip all the tab
      flip.tend(auction, 10 ether, 1 ether);  // bid 1 dai
      assertEq(dai(urn1), 14 ether);

      // tag and fix computation
      uint hump = 0;
      uint tag = RAY / 5;
      uint fix = RAY / 5;
      end.cage(hump);
      end.cage("gold", tag, fix);

      end.skip("gold", auction);
      assertEq(dai(urn1), 15 ether);          // bid refunded
      assertEq(vat.vice(), 0);                // sin is gone

      end.skim("gold", urn1);

      // local checks:
      assertEq(art("gold", urn1), 0);
      assertEq(ink("gold", urn1), 7 ether);
      assertEq(vat.sin(bytes32(bytes20(address(end)))), rad(15 ether));

      // global checks:
      assertEq(vat.debt(), rad(15 ether));
      assertEq(vat.vice(), rad(15 ether));

      // CDP closing
      end.free("gold");
      assertEq(ink("gold", urn1), 0);
      assertEq(gem("gold", urn1), 7 ether);
      gemA.exit(urn1, address(this), 7 ether);

      // dai redemption
      end.shop(15 ether);

      // global checks:
      // no need for vent
      assertEq(vat.debt(), 0);
      assertEq(vat.vice(), 0);

      end.pack("gold");
      end.cash("gold");

      // local checks:
      assertEq(dai(urn1), 0);
      assertEq(gem("gold", urn1), 3 ether);
      gemA.exit(urn1, address(this), 3 ether);

      assertEq(gem("gold", bytes32(bytes20(address(end)))), 0);
      assertEq(gold.balanceOf(address(gemA)), 0);
  }
#+END_SRC

* Further Work

** Dai-parity by socialising proportionally to collateral

Here, well-collateralised CDPs are effectively used to bail out undercollaterised positions. This mechanism is already in use in the current, single collateral, version of Dai.

** Dai-parity by socialising proportionally to equity

This would be a novel mechanism, similar to collateral-proportional, but instead considering the /equity/ of a CDP:

\[ {\tt E_{iu}} = {\tt art_{iu}} \cdot {\tt rate_i} - p_{{\tt i}} \cdot {\tt ink_i} \]

** NFT Settlement Modules (TODO)

NFTs need to be dealt with separately, by assigning ownership of the tokens and their associated debt to a special settlement module.
