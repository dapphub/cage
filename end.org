#+TITLE: `cage`
#+DATE: <2019-01-24 Thu>
#+AUTHOR:
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+OPTIONS: html-postamble:nil tex:mathjax
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export
#+PROPERTY: header-args :results output :exports both :noweb strip-export :tangle no :mkdirp yes
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./body.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="./theme.css"/>
#+HTML_HEAD_EXTRA: <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="/home/lev/src/MathJax/MathJax.js?config=TeX-AMS_HTML-full"><\/script>')</script>

#+OPTIONS:
# Local Variables:
# org-confirm-babel-evaluate: nil
# org-babel-exp-code-template: "#+BEGIN_SRC %lang%switches%flags\n%body\n#+END_SRC"
# End:

* License
#+NAME: license
#+BEGIN_SRC fundamental
  Copyright (C) 2018 Rain <rainbreak@riseup.net>
  Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC


* Introduction
=`cage`= is the most complex mechanism in =dss=. It must alter the behaviour of almost every component of the system and it must perform under a variety of possible (under)collateralisation regimes. In particular, there are a number of key properties, such as dai and CDP parity, or the lack of race conditions, which should be guaranteed even in edge cases, e.g. in the presence of CDPs which have become less than 100% collateralised. This means that a relatively complex calculation must be performed to determine the correct rates for collateral redemption by dai and CDP owners. Since in some edge cases it will not be possible to satisfy all desirable properties at once, a choice must be made about which to prioritise.

The procedure for =cage= looks roughly as follows:
1. Beforehand, the =End= contract is configured with the addresses of the =Vat=, =Vow=, =Cat=, and the price feed coordinator =Spot=. A suitable cooldown period =wait= is chosen. An appropriate entity which will be allowed to initiate global settlement is added as an owner of the =End=.
2. When the time comes to globally settle the system, the top-level =cage= method is called by an authorised party, which puts all system components into post-=cage= mode, and starts the cooldown timer. All subsequent steps are completely permissionless and can be triggered by anyone.
3. For each collateral type, the per-=Ilk= =cage= method is called. This fetches the feed price from the =spot= to set the =tags=, which are the prices at which all CDPs of that collateral type will be settled.
4. CDPs that are not undercollateralised can immediately be settled with =skim=, and the collateral can be withdrawn by their owner with =free=.
5. Any CDPs which are _undercollateralised_, i.e. whose debt is greater in value than their collateral as judged by the =tag=, are settled by calling =bail=.
6. Any ongoing collateral auctions that have not yet raised the dai to cover their debt are blocked from finalising, and are reversed by calling =skip=, returning the collateral and debt to the original CDP.
7. Once the cooldown timer has finished, =thaw= and =flow= are called to fix the dai redemption rates, called =fixs=. It is assumed that all undercollateralised positions have been =bail=ed by this point, and all deficit auctions have been =skip=ped, i.e. we assume that during the cooldown period steps 5 and 6 were completed.
8. dai holders can redeem the collateral they are entitled to by going through =shop=, =pack=, and =cash=.

At this point, any outstanding `Flip` auctions that have not yet raised their target amount of dai can be cancelled ("yanked") by calling the public method =skip(uint id)=. When an auction is yanked, the collateral and debt are assigned back to the original CDP, which will then be settled as if it had not yet been liquidated, and the highest bidder is refunded their dai. Auctions that have already raised their target amount of dai are allowed to proceed and can receive further =dent= bids and settle as normal.

For the purposes of the upcoming calculation, we will assume that all yankable auctions have been yanked. In particular, when the cooldown period has elapsed and =flow= is executed, we will assume that the outstanding =Art= for each =Ilk= has been updated to include all CDPs that were previously in liquidation that had not yet raised enough dai to cover their debt.

** Interlude: the =fix= computation

The =fix= represents the quantity of =gem= that a user will be able to redeem for one dai. We now describe the procedure by which it should be computed. In the following calculation, for notational simplicity, the appropriate operations for fixed point units are implicit, e.g. \( {\tt art_{iu}} \cdot {\tt rate_i} \) is the outstanding dai debt of CDP =u=, etc.

In this case, the total quantity of dai that must be redeemable through =End= is the dai supply once all dai surplus in the =Vow= has been removed. We will denote this quantity by \( debt^\prime \).

The first priority is to ensure that there is no race condition. That is to say, that with the \( {\tt fix_i}\) and \({\tt tag_i} \) that we chosen, every dai holder will be able to redeem the same quantity of =gem=, regardless of when they interact with the =End=. Let \( {\tt war_{iu}} \) denote the amount of collateral of type =i= taken from the urn =u= that will go to dai redemption. Then this property can be expressed as:

\[
\sum_u {\tt war_{iu}} = {\tt fix_i} \cdot {\tt debt}^\prime
\]

We shall call this the /no-race property/. Setting \( {\tt war_{iu}} \) to be \( \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i }) \), where \( {\tt tag_i} \) is the /CDP settlement rate/, we can solve for \( {\tt fix_i } \):

\[
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, {\tt art_{iu}} \cdot {\tt rate_i} \cdot {\tt tag_i })}{{\tt debt}^\prime}
\]

Similarly, it is desirable for CDPs to be settled at the market value of their collateral, i.e. that:

\[
{\tt tag_i } = \frac{1}{p_i}
\]

We call this the /CDP parity property/.

Another desirable feature is for all =gem= redeemable for one dai to be worth one dollar:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = 1
\]

We call this the /dai parity property/. As we shall see, it might not be satisfied if the system is in deficit.

**** In the absence of undercollateralised positions

Consider the case where no CDPs are undercollateralised, i.e. that for all =u=, \( {\tt art_{iu}} \cdot {\tt rate_i} \geq {\tt ink_{iu}} \cdot p_{{\tt i}} \). Then we can satisfy all three constraints simultaneously simply by setting \( {\tt tag_i} = \frac{1}{p_{{\tt i}}} \):

\[
{\tt fix_i} = \frac{{\tt rate_i} \cdot {\tt tag_i } \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt rate_i} \cdot {\tt Art_i}}{p_{{\tt i}}\cdot({\tt debt}^\prime - {\tt hump \cdot dump })}
\]

Writing \( {\tt pump} := \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump}\cdot{\tt dump}} \) for the /=hump= burn multiplier/:

\[
\sum_i {\tt fix_i} \cdot p_{{\tt i}} = \frac{\sum_i {\tt rate_i} \cdot {\tt Art_i}}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt debt}^\prime}{{\tt debt}^\prime - {\tt hump \cdot dump }} = {\tt pump}
\]

from which it is clear that we could use \( {\tt dump } = 0 \) and satisfy the no-race property and both parity properties.

**** In the presence of undercollateralised positions

Now if some CDPs had been undercollateralised, we would have had instead:

\begin{equation}
\label{eq:fixcdpparity}
{\tt fix_i} = \frac{\sum_u \mathrm{min}({\tt ink_{iu}}, \frac{{\tt art_{iu}} \cdot {\tt rate_i}}{p_{{\tt i}}})}{{\tt debt}^\prime - {\tt hump \cdot dump }} = \frac{{\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i}}{p_{{\tt i}}({\tt debt}^\prime - {\tt hump \cdot dump })}
\end{equation}

and the value redeemable from one dai would be:

\begin{align*}
\sum_i {\tt fix_i} \cdot p_{{\tt i}} & = \frac{\sum_i {\tt Art_i} \cdot {\tt rate_i} - {\tt gap_i} }{{\tt debt}^\prime - {\tt hump \cdot dump }} \\
                                     & = \frac{{\tt debt} - {\tt Gap}}{{\tt debt}^\prime - {\tt hump \cdot dump }}
\end{align*}

where \( {\tt gap_i} := \sum_u \mathrm{max} (0, {\tt art_{iu}} \cdot {\tt rate_i} - p_{{\tt i}} \cdot {\tt ink_i}) \) and \( {\tt Gap} := \sum_i {\tt gap_i} \), are the per =Ilk= and global gross negative CDP equity, respectively. Thus, though we have ensured the no-race and CDP parity properties, we have not necessarily ensured dai parity. However, if =hump= is large enough relative to =Gap=, it may be possible to ensure that the above expression equals one, solely by increasing =dump=.

** CDP Settlement
Once =tag_i= has been provided, individual CDPs can be processed with =skim=, settling the position at the price implied by =tag_i=. This method is public, and both CDP holders and dai holders are incentivised to call it: the former in order to withdraw their remaining collateral, and the latter in order to make collateral available for redemption.

* Further Work

** NFT Settlement Modules (TODO)

NFTs need to be dealt with separately, by assigning ownership of the tokens and their associated debt to a special settlement module.
